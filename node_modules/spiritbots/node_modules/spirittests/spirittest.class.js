'use strict';

/**
 * @class Collects tests from the tests folder.  If a current test runner
 * exists, then test files are included via a requires statement.  If no test
 * runner exists, tests may be executed to yield a true/false result if the 
 * tests pass.
 */
class SpiritTests {
    constructor() {
        if (SpiritTests.instance) {
            SpiritTests.instance.initialize();
            return SpiritTests.instance;
        }
        /** @type {SpiritTests} Singleton instance */
        SpiritTests.instance = this;
        /** @type {Boolean} True if Jasmine is instantiated by SpiritTests. */
        this.customRunner = false;
        /** @type {Array<string>} Array of files. */
        this.files = [];
        /** @type {Object} */
        this.fs = require('fs');
        /** @type {Array} */
        this.promises = [];
        /** @type {SpiritFiles} */
        this.spiritfiles = require('spiritfiles');
    }

    /**
     * Configures Jasmine to utilize the existing tests.
     */
    configureJasmine() {
        this.jasmine.completionReporter.onComplete((passed) => {
            for (let promise of this.promises) {
                if (passed) {
                    promise[0]();
                } else {
                    promise[1]();
                }
            }
            this.promises = [];
        });
    }

    /**
     * Creates a test using the fn parameter.  Stores it in a file with an
     * optional name.  If no name is provided, then the file is automatically
     * named.
     * @param {function} fn The function to create the test with.
     * @param {string} name (Optional) The filename to use.
     */
    createTest(fn, name) {
        if (!name) {
            if (this.files.length == 0) {
                this.readTests();
            }
            name = this.files.length;
            while (this.fs.existsSync('tests/test' + name + '.js')) {
                name++;
            }
            name = 'test' + name + '.js';
        }
        fn = fn.toString();
        fn = fn.substr(fn.indexOf('{') + 1, 
            fn.length - fn.indexOf('{') - 
            (fn.length - fn.lastIndexOf('}') + 1));
        this.spiritfiles.createLocalFile('tests', name, fn, true);
    }

    /**
     * For each test, runs the tests inside the Jasmine test runner.  Produces
     * a result that is true/false.
     * @return {Boolean} True if the tests pass.
     */
    execute() {
        let promise;
        this.readTests();
        promise = new Promise((resolve, reject) => {
            this.promises.push([resolve, reject]);
        });
        try {
            this.jasmine = this.getTestRunner(true);
            this.configureJasmine();
            this.jasmine.env.clearReporters();
            this.jasmine.execute(this.files);
        } catch(e) {
            console.log(e);
        }
        return promise;
    }
    

    /**
     * Returns Jasmine object.
     * @param {Boolean} forceNew If true, forces a new Jasmine object to be
     *     created.
     * @return {Jasmine} Jasmine object.
     */
    getTestRunner(force = false) {
        if (!force && global.hasOwnProperty('jasmine')) {
            return global.jasmine;
        } else {
            return new (require('jasmine'))();
        }
    }

    /**
     * @return {Boolean} True if active test runner.
     */
    hasActiveTestRunner() {
        return global.hasOwnProperty('jasmine');
    }

    /**
     * Includes tests found via readTests.
     */
    includeTests() {
        let file;
        if (this.files.length == 0) {
            this.readTests();
        }
        for (file of this.files) {
            delete require.cache[file];
            try {
                describe('SpiritTests test automatically loaded  from ' + 
                    file, () => {
                    require(process.cwd() + '/' + file);
                });
            } catch(e) {}
        }
    }

    /**
     * Initializes the test runner via inclusion or instantiation.
     * @return {Promise} A promise that resolves when the test runner has 
     * initialized with the tests.
     */
    initialize() {
        if (this.hasActiveTestRunner()) {
            this.includeTests();
            this.customRunner = false;
            /** @type {Jasmine} */
            this.jasmine = this.getTestRunner();
        } else {
            /** @type {Jasmine} */
            this.jasmine = this.getTestRunner();
            this.configureJasmine();
            this.customRunner = true;
        }
    }

    /**
     * Reads the tests from the tests folder.
     */
    readTests() {
        let file;
        this.files = this.spiritfiles.readLocalFiles('tests');
    }
}

module.exports = new SpiritTests();