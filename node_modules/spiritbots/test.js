assert  = require('assert');
fs      = require('fs');
require('spiritconfigs/spiritconfigs.class.js').setOverride('spiritbots', {'manualAPIStart': 1});
Robots  = require('./index.js');
rimraf  = require('rimraf');

describe('robots', function() {
    beforeEach(function() {
        jasmine.DEFAULT_TIMEOUT_INTERVAL = 20000;
    });
    it('should register signals', function() {
        // register some other functions
        Robots.register('a', function(){
            return 'a';
        });
        var sID = Robots.register('a', function(){
            return 'b';
        });
        Robots.register('b', function(){
            return 'd';
        });
        Robots.register('a', function(){
            return 'c';
        });

        assert(Robots.relay('a').length==3, "Robots.relay is not returning correct length of results");

        Robots.registerIfNot('a', function() {
            return 'e';
        });

        assert(Robots.relay('a').length==3, "Robots.registerIfNot is not working");

        assert(Robots.relay('a')[1]=='b', "Robots.relay is not returning correct result");
        Robots.clearSignalById(sID);
        assert(Robots.relay('a')[1]=='c', "Robots.relay is not returning correct result");
        assert(Robots.answer('a')=='c', "Robots.answer is not working");

        Robots.clear('a');
        Robots.clear('b');
        assert(Robots.answer('a')==undefined, "Robots.clear not working");
    });

    it('should allow multiple signals to register per call', function() {
        var i;
        i = 0;
        Robots.register(['a', 'b'], function() {
            i++;
        })
        Robots.relay('a');
        expect(i).toBe(1);
        Robots.relay('b');
        expect(i).toBe(2);
        Robots.clear(['a', 'b']);
        Robots.relay('a');
        expect(i).toBe(2);
    })

    it('should speedily allow many signals to register', function() {
        var len = Robots.relay('a').length;
        var arr = [];
        for ( var i=0; i < 100; i++ ) {
            arr.push(Robots.register('a',function(){
            }));
        }

        assert(Robots.relay('a').length==len+100, "Robots.relay breaks with scale");
    });

    it('should correctly load signals, traversing folders', function() {
        var cwd;
        cwd = process.cwd();
        if (!fs.existsSync('node_modules'))
            fs.mkdirSync('node_modules');

        process.chdir('node_modules');
        fs.mkdirSync('robotsTestModule');
        process.chdir('robotsTestModule');
        fs.mkdirSync('node_modules');
        fs.mkdirSync('signals');
        fs.mkdirSync('customSignals');
        fs.writeFileSync('signals/testSignal1.js', 'module.exports = function() { return "success :)"; }');
        fs.writeFileSync('customSignals/testSignal2.js', 'module.exports = function() { return "success :))"; }');
        process.chdir('node_modules');
        fs.mkdirSync('robotsNestedTestModule');
        process.chdir('robotsNestedTestModule');
        fs.mkdirSync('signals');
        fs.mkdirSync('customSignals');
        fs.writeFileSync('signals/testSignal3.js', 'module.exports = function() { return "success :)))"; }');
        fs.writeFileSync('customSignals/testSignal4.js', 'module.exports = function() { return "success :))))"; }');
        process.chdir(cwd);

        expect(!Robots.Callbacks.hasOwnProperty('testSignal1')).toBe(true);
        expect(!Robots.Callbacks.hasOwnProperty('testSignal2')).toBe(true);
        expect(!Robots.Callbacks.hasOwnProperty('testSignal3')).toBe(true);
        expect(!Robots.Callbacks.hasOwnProperty('testSignal4')).toBe(true);

        Robots.signals.readSignals();

        expect(Robots.Callbacks.hasOwnProperty('testSignal1')).toBe(true);
        expect(!Robots.Callbacks.hasOwnProperty('testSignal2')).toBe(true);
        expect(Robots.Callbacks.hasOwnProperty('testSignal3')).toBe(true);
        expect(!Robots.Callbacks.hasOwnProperty('testSignal4')).toBe(true);

        expect(Robots.Callbacks['ping'].length).toBe(1); // verifies a "readSignals" call loads only unique signals

        Robots.signals.readSignals('customSignals');

        expect(Robots.Callbacks.hasOwnProperty('testSignal2')).toBe(true);
        expect(Robots.Callbacks.hasOwnProperty('testSignal4')).toBe(true);

        process.chdir(cwd);
        process.chdir('node_modules');
        rimraf('robotsTestModule', function() {
        });
    });

    Robots.runTests(function(signal, callback, description) {
        it('should successfully run ' + signal + ': ' + description, function(done) {
            var fn;
            fn = function() { return Robots.answer.apply(Robots, [signal].concat(Array.prototype.slice.call(arguments, 0))); };
            callback(fn, done);
        });
    });

    it('should allow relays to be performed asynchronously', function(done) {
        // TODO me
        Robots.register('async', function(a) {
            var s;
            if (typeof a == 'undefined' || typeof a == 'function')
                a = 0;
            s  = Robots.wait();

            setTimeout(function() {
                Robots.finish(s, 1 + a);
            });
        });

        Robots.register('async2', function(a) {
            var s;
            if (typeof a == 'undefined' || typeof a == 'function')
                a = 0;
            s  = Robots.wait();

            setTimeout(function() {
                Robots.finish(s, 1 + a);
            });
        });

        Robots.register('async2', function(a) {
            var s;
            if (typeof a == 'undefined' || typeof a == 'function')
                a = 0;
            s  = Robots.wait();

            setTimeout(function() {
                Robots.finish(s, 2 + a);
            });
        });

        Robots.register('async2', function(a) {
            return 3 + a;
        });

        Robots.register('async-multiple-waits', function(a) {
            // this should call the wait function more than once
            Robots.wait();
            s = Robots.wait();
            setTimeout(function() {
                Robots.finish(s, 1 + a);
            })
        });

        Robots.relayAsync('async', function(r) {
            expect(r[0]).toBe(1);
            Robots.relayAsync('async', 1, function(r) {
                expect(r[0]).toBe(2);
                Robots.answerAsync('async', 2, function(r) {
                    expect(r).toBe(3);
                    Robots.relayAsync('async2', 1, function(r) {
                        expect(r[0]).toBe(2);
                        expect(r[1]).toBe(3);
                        expect(r[2]).toBe(4);
                        Robots.answerAsync('async2', 1, function(r) {
                            expect(r).toBe(4);
                            Robots.answerAsync('async-multiple-waits', 1, function(r) {
                                expect(r).toBe(2);
                                done();
                            });
                        });
                    });
                });
            });
        });
    });

    it('should allow connectivity over the network', function(done) {
        Robots.api.open(function(port) {
            Robots.answerAsync('ping', 'http://localhost:' + port, function(open) {
                expect(!open);
                Robots.api.close();
                Robots.answerAsync('ping', 'http://localhost:' + port, function(open) {
                    expect(open);
                    var r2 = Robots.copy();
                    r2.api.open(function(port) {
                        Robots.answerAsync('ping', 'http://localhost:' + port, function(open) {
                            expect(!open);
                            Robots.api.close();
                            Robots.answerAsync('ping', 'http://localhost:' + port, function(open) {
                                expect(open);
                                done();
                            });
                        });
                    });
                });
            });
        });
    });

    it('should allow configurable servers', function(done) {
        done();
    });

    it('should allow multiple servers to open', function(done) {
        Robots.api.open(function(p1) {
            Robots.api.open(function(p2) {
                Robots.api.close();
                Robots.answerAsync('ping', 'http://localhost:' + p1, function(open) {
                    expect(open);
                    Robots.answerAsync('ping', 'http://localhost:' + p2, function(open) {
                        expect(open);
                        done();
                    });
                });
            });
        });
    });

    it('should properly allow two servers to connect', function(done) {
        var r2;
        r2 = Robots.copy();
        Robots.api.open(function(p1) {
            r2.api.open(function(p2) {
                Robots.http.registerHub('http://localhost:' + p2, function() {
                    expect(Object.keys(r2.http.nodes).indexOf('127.0.0.1' + ':' + p1) >= 0);
                    expect(Object.keys(Robots.http.hubs).indexOf('127.0.0.1' + ':' + p2) >= 0);
                    Robots.http.unregisterHub('http://localhost:' + p2, function() {
                        expect(Object.keys(r2.http.nodes).indexOf('127.0.0.1' + ':' + p1) < 0);
                        expect(Object.keys(Robots.http.hubs).indexOf('127.0.0.1' + ':' + p2) < 0);
                        done();
                    });
                });
            });
        });
    });

    it('should allow connectivity between servers', function(done) {
        var onNetworked, r2, r3;
        r2 = Robots.copy();
        r3 = Robots.copy();

        var signalsObj_ = {};
        signalsObj_['fn1'] = function (){};
        signalsObj_['fn2'] = function (){};
        signalsObj_['fn3'] = function (){};
        r2.register('a', function() {
            (signalsObj_['fn1'])();
        });
        r2.register('returnBeaconTest', function() {
            return 'a';
        }, '', {'returnBeacon': true});
        r2.register('returnBeaconTest', function() {
            return 'b';
        }, '', {'returnBeacon': false})
        Robots.register('b', function() {
            (signalsObj_['fn2'])();
        });
        r3.register('b', function() {
            (signalsObj_['fn3'])();
        });

        onNetworked = function() {
            spyOn(signalsObj_, 'fn1');
            spyOn(signalsObj_, 'fn2');
            spyOn(signalsObj_, 'fn3');
            Robots.http.beacon('a', function(body) {
                expect(signalsObj_['fn1']).toHaveBeenCalled();
                expect(body).toBe('ok');
                Robots.http.beacon('returnBeaconTest', function(body) {
                    expect(body.length).toBe(1);
                    expect(body[0]).toBe('a');
                    r2.http.broadcast('b', function() {
                        expect(signalsObj_['fn2']).toHaveBeenCalled();
                        expect(signalsObj_['fn3']).toHaveBeenCalled();
                        done();
                    });
                });
            });
        }

        Robots.api.open(function(p1) {
            r2.api.open(function(p2) {
                r3.api.open(function(p3) {
                    Robots.http.registerHub('http://localhost:' + p2, function() {
                        r3.http.registerHub('http://localhost:' + p2, function() {
                            onNetworked();
                        });
                    });
                });
            });
        });
    });
});