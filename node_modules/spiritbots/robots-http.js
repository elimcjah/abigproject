var settings = require('spiritconfigs').spiritbots;

/**
 * @class
 */
var RobotsHTTP = (function() {
    /** @type {Object} request dependency for HTTP calls */
    this.request    = {};

    /** @type {Object} contains settings and supported signals for nodes */
    this.nodes  = {};

    /** @type {Object} hubs to receive signals from */
    this.hubs   = {};

    this.id = Math.random();

    /**
     * include relevant packages
     */
    this.requireExternalDependencies = function() {
        this.request        = require('request');
    };

    /**
     * registers a node, and expects to know that nodes settings and supported signals
     * @param  {String} host     address to send/receive to/from
     * @param  {Object} settings that determine how to interact
     * @param  {Array} signals  listing so only supported signals are communicated
     */
    this.registerNode = function(host, settings, signals){
        this.nodes[host]    = {
            "settings": settings,
            "signals": signals
        };
    };

    /**
     * removes a node from the node list
     * @param {String} host to remove
     */
    this.unregisterNode = function(host){
        delete this.nodes[host];
    };

    /**
     * registers a hub such that this server becomes a node
     * @param  {String} host address to add as hub
     */
    this.registerHub = function(host) {
        var args, fn, host, self;
        self = this;

        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal

        fn  = args[args.length-1];
        if (typeof fn != "function")
            fn      = function(){};
        else
            fn      = args.pop();

        host = this.parent().answer('url-parts', host);
        if (typeof host == 'undefined')
            return;
        host['host'] = host['host'].replace(/localhost/gi, '127.0.0.1');
        host = host.host;

        this.parent().relayAsync('ping', host, function(s){
            if (!s)
                return; // this host is not allowing a socket connection to occur

            rsettings   = encodeURIComponent(JSON.stringify(settings));
            signals     = encodeURIComponent(JSON.stringify(Object.keys(self.parent().Callbacks)));
            self.request({
                "url": self.parent().answer('normalize-url',host+"/api/robots/checkin")+"?settings="+rsettings+"&password="+settings.password+"&signals="+signals,
                "headers": {
                    "port": self.parent().api.port
                }
            }, function(err,response,body){
                if ( !err && response.statusCode == 200 ) {
                    self.hubs[host] = JSON.parse(body);
                    fn(true);
                }
                else
                    fn(false);
            });
        });
    };

    /**
     * unregisters a hub, checking out from that hub in the process
     * @param {String} host disconnects this endpoint as a hub
     */
    this.unregisterHub  = function(host) {
        var args, fn, host, self;
        self = this;

        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal

        fn  = args[args.length-1];
        if (typeof fn != "function")
            fn      = function(){};
        else
            fn      = args.pop();

        host = this.parent().answer('url-parts', host);
        host['host'] = host['host'].replace(/localhost/gi, '127.0.0.1');
        host = host.host;

        this.parent().relayAsync('ping', host, function(s){
            if (!s)
                return; // this host is not allowing a socket connection to occur

            self.request({
                "url": self.parent().answer('normalize-url',host+"/api/robots/checkout"),
                "headers": {
                    "port": self.parent().api.port
                }
            }, function(err,response,body){
                if ( !err && response.statusCode == 200 ) {
                    delete self.hubs[host];
                    fn(true);
                }
                else
                    fn(false);
            });
        });
    };

    /**
     * beacon a signal to a hub, no result needed (1-way communication)
     * @param  {String} signal to send
     */
    this.beacon   = function(signal){
        var args, fn;
        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal

        fn  = args[args.length-1];
        if (typeof fn != "function")
            fn      = function(){};
        else
            fn      = args.pop();

        var self = this;

        for ( var i in this.hubs ){
            this.request.post({
                'url': this.parent().answer('normalize-url',i)+'/api/robots/return/',
                'headers': {
                    'port': self.parent().api.port
                },
                "form": {
                    'signal':signal,
                    'args':args
                }
            }, function(err,response,body){
                try {
                    body = JSON.parse(body);
                    fn(body);
                } catch(e) {
                    fn(body);
                }
            });
        }
        this.parent().relay.apply(this.parent(),arguments);
    }

    /**
     * broadcast a signal to all nodes,
     * this is the slowest way to send over the network
     * @param  {String} signal to send
     * @return {*} all results returned from all machines
     */
    this.broadcast = function(signal){
        var args, i, fn, options, results, reqIn, reqOut, s;
        // broadcasts the signal to this box's nodes
        // and also the hubs (but they may ignore it)
        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal
        fn  = args[args.length-1];
        if (typeof fn != "function")
            fn      = function(){};
        else
            fn      = args.pop();

        args    = encodeURIComponent(JSON.stringify(args));
        s  = this.parent().wait();
        reqOut  = 0;
        reqIn   = 0;
        results = {};
        var collectResult   = function(h,r) {
            if (typeof r != 'undefined' && typeof r[0] != 'undefined')
                results[h]  = JSON.parse(r);
        }
        var finished    = function() {
            fn(results);
        }

        for (i in this.nodes){
            // screen the node so that it has the signal
            if (this.nodes[i].signals.indexOf(signal) == -1)
                continue;
            // i is the host, broadcast to everybody
            reqOut++;
            var self    = this;
            (function(host){
                setTimeout(function(){
                    self.request({
                        'url': self.parent().answer('normalize-url',host)+'/api/robots/signal/'+'?signal='+signal+'&args='+args,
                        'headers': {
                            'port': self.parent().api.port
                        }}, function(err,response,body){
                        // the response is then returned to this signal
                        collectResult(host,body);
                        reqIn++;
                        if ( reqIn == reqOut )
                            finished();
                    });
                }); // give the iteration some time to process
            })(i);
        }
        // add in this current server
        collectResult("http://localhost:" + self.parent().api.port, self.parent().relay.apply(self.parent(),arguments));
        return s;
    };

    /**
     * delegates a signal to one machine
     * @param  {String} signal to send
     */
    this.delegate = function(signal){
        // this works like broadcast but limits
        // so that only one machine may process the signal
        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal
        fn  = args[args.length-1];
        if ( typeof fn != "function" )
            var fn      = function(){};
        else
            var fn      = args.pop();
        this.broadcast.apply(this.parent(),[signal].concat(args).concat([function(r){
            if ( typeof r != "object" )
                return;
            keys    = Object.keys(r);
            fn(r[keys[0]]);
        }]));
    };

    /**
     * all nodes process, one result returned from one machine
     * @param  {String} signal the signal to send for an answer
     */
    this.delegateAnswer = function(signal) {
        // this works like broadcast but limits
        // so that only one machine may process the signal
        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal
        fn  = args[args.length-1];
        if ( typeof fn != "function" )
            var fn      = function(){};
        else
            var fn      = args.pop();
        this.broadcast.apply(this.parent(),[signal].concat(args).concat([function(r){
            if ( typeof r != "object" )
                return;
            keys    = Object.keys(r);
            fn(r[keys[0]][0]);
        }]));
    };

    /**
     * one machine processes, all results returned from one machine
     * @param  {String} signal to send for processing
     */
    this.processSignal  = function(signal){
        // broadcasts the signal to this box's nodes
        // and also the hubs (but they may ignore it)
        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal
        fn  = args[args.length-1];
        if ( typeof fn != "function" )
            var fn      = function(){};
        else
            var fn      = args.pop();

        args    = encodeURIComponent(JSON.stringify(args));
        var s  = this.parent().wait();
        var results = {};

        matches = {};
        for ( var i in this.nodes ){
            // screen the node so that it has the signal
            if ( this.nodes[i].signals.indexOf(signal) == -1 )
                continue;
            matches[i]  = this.nodes[i];
        }

        var hosts   = Object.keys(matches);
        var n       = Math.floor(Math.random()*(hosts.length+1))-1;
        while ( n != -1 && this.nodes[hosts[n]].signals.indexOf(signal) == -1  )
            n       = Math.floor(Math.random()*(hosts.length+1))-1;

        // process locally
        if ( n == -1 )
            return this.relay.apply(this.parent(),arguments);

        // i is the host, broadcast to everybody
        var host    = hosts[n];
        var self    = this;
        (function(host){
            setTimeout(function(){
                self.request({
                    'url': self.answer('normalize-url',host)+'/api/robots/signal/'+'?signal='+signal+'&args='+args,
                    'headers': {
                        'port': self.parent().api.port
                    }}, function(err,response,body){
                    // the response is then returned to this signal
                    result  = {};
                    result[host]    = body;
                    fn(result);
                });
            },2); // give the iteration some time to process
        })(host);
        return s;
    };

    /**
     * one machine processes, one result returned from one machine
     * @param  {String} signal to send
     */
    this.processAnswer    = function(signal){
        args    = Array.prototype.slice.call(arguments,0);
        args.shift(); // this is the signal
        fn  = args[args.length-1];
        if ( typeof fn != "function" )
            var fn      = function(){};
        else
            var fn      = args.pop();
        this.processSignal.apply(this.parent(), [signal].concat(args).concat([function(r){
            if ( typeof r != "object" )
                return;
            keys    = Object.keys(r);
            fn(r[keys[0]]);
        }]));
    };

    this.requireExternalDependencies();

    return this;
});

module.exports = RobotsHTTP;