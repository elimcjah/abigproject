<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Robots is a simple pub/sub message bus with async capabilities
 * @module Spiritbots
 */

var fs  = require('fs');
var RobotsAPI = require('./robots-api.js');
var RobotsHTTP = require('./robots-http.js');
var RobotsSignals = require('./robots-signals.js');
var configs = require('spiritconfigs');

/**
 * @class Robots
 */
var RobotsClass  = (function(){
    /**
     * @typedef {Array&lt;String, number, Boolean>} Signal
     */
    
    /**
     * all callbacks are stored on this object
     * @type {Object&lt;String, Signal>}
     */
    this.Callbacks  = {};

    /**
     * all tests are stored on this object, same format as Callbacks
     * @type {Objct&lt;String, Signal>}
     */
    this.Tests      = {};

    /**
     * all onetimes are stored on this object
     * @type {Object&lt;string, Signal>}
     */
    this.OnetimeCallbacks   = {};

    /**
     * counts the number of registered signals, increments each new signal
     * @type {Number}
     */
    this.numRegistered  = 0;
    /**
     * stores the last registered callback array
     * @type {Signal}
     */
    this.lastRegistration   = [];

    /**
     * stores the current signal being called
     * @type {String}
     */
    this.currentSignal  = "";

    /**
     * stores the current signal call being made (for backtraces, etc.)
     * @type {Number}
     */
    this.callbackID = 0;

    /**
     * @alias Robots.Clear
     */
    this.clear  = function(signal) {
        this.Clear(signal);
    };

    /**
     * clears every callback for a signal
     * @param {String} signal to clear
     */
    this.Clear  = function(signal) {
        var obj = this;
        if ( Array.isArray(obj.Callbacks[signal]) ) {
            obj.Callbacks[signal]   = [];
            delete obj.Callbacks[signal];
        }
    };

    /**
     * @alias Robots.NumCallbacks
     */
    this.numCallbacks    = function(signal) {
        this.numCallbacks(signal);
    };

    /**
     * gets the number of callbacks for a given signal
     * @param {String} signal to get num callbacks for
     * @return {Number} the number of callbacks
     */
    this.NumCallbacks    = function(signal) {
        var callbacks = this.Callbacks[signal] ? this.Callbacks[signal].length : 0;
        var onetimeCallbacks = this.OnetimeCallbacks[signal] ? this.OnetimeCallbacks[signal].length : 0;
        return callbacks + onetimeCallbacks;
    };

    /**
     * generates a wait token, indicating current callee should
     * wait for a finish function to be called
     * @see Robots.finish
     * @return {String} a new 
     */
    this.wait   = function() {
        return "robots-async-signal-"+(this.callbackID);
    };

    /**
     * @param  {String} id as returned by wait
     * @param  {Object} data to pass into the callback
     */
    this.finish    = function(id,data) {
        // should now end 
        this.relay(id,data);
    };

    /**
     * @alias Robots.finish()
     */
    this.Finished   = function() {
        var obj = this;
        return this.finished.apply(obj,arguments);
    };

    /**
     * @param  {Object} obj which takes the result of a signal call
     * @param  {Function} cb to be called with the returned data
     * @return {Array&lt;Signal>} an array of signals 
     */
    this.finished   = function(obj,cb,numCalls) {
        var cin = 0;
        var cout= 0;
        var ctotal = this.callbackID - numCalls;
        var executed=false; // added 10-24-15
        var i;
        var results = {};
        var resultsArr = [];
        var self = this;
        for (i in obj) {
            cin++;
            if ( typeof obj[i] == "string" &amp;&amp; obj[i].substr(0,"robots-async-signal-".length) == "robots-async-signal-" )
                continue;
            else if (typeof obj[i] == 'undefined')
                continue;
            else {
                cout++;
                results[i] = obj[i];
            }
        }
        if (cout >= cin) {
            for (var i in results)
                resultsArr.push(results[i])
            cb.call(this, resultsArr);
            return;
        }
        for (i = 0; i &lt; ctotal; i++ ) {
            (function(signal, i, c) {
                self.registerOnce(signal, function(r){
                    results[i] = r;
                    cout++;
                    if ( cout >= cin &amp;&amp; !executed ) {
                        executed=true;
                        for (var j in results)
                            resultsArr.push(results[j])
                        c.call(self, resultsArr);
                    }
                });
            })("robots-async-signal-" + (numCalls + i + 1), i, cb)
        }

        if ( cin == 0 )
            cb(obj);

        return obj;
    };

    /**
     * @alias Robots.clearSignalById
     */
    this.clearSignalById  = function(arr) {
        this.ClearSignalById(arr);
    };

    /**
     * @param {Array} arr to clear
     */
    this.ClearSignalById    = function(arr) {
        var obj;
        obj = this;
        if ( arr[2] )
            obj.OnetimeCallbacks[arr[0]].splice(arr[1],1);
        else
            obj.Callbacks[arr[0]].splice(arr[1],1);
    };

    /**
     * @alias Robots.RegisterOnce
     */
    this.registerOnce   = function(signal, callback) {
        var obj = this;
        return this.RegisterOnce.apply(obj,arguments);
    };

    /**
     * Registers a signal to be called only one time, then these registrant is removed
     * @param  {String} signal to register
     * @param  {Function} callback to call when the signal is relayed
     * @return {*}
     */
    this.RegisterOnce   = function(signal, callback) {
        var obj = this;
        if ( !Array.isArray(obj.OnetimeCallbacks[signal]) )
            obj.OnetimeCallbacks[signal]   = [];

        var cb = {'onetime':true,'fn':callback};
        obj.OnetimeCallbacks[signal].push(cb);
        obj.lastRegistration = [true, signal, obj.OnetimeCallbacks[signal].length-1];

        obj.numRegistered++;
        return [signal,obj.OnetimeCallbacks[signal].length-1,true];
    };

    /**
     * @alias Robots.Answer
     */
    this.answer     = function(signal) {
        var obj = this;
        return this.Answer.apply(obj,arguments);
    };

    /**
     * Answer signals to the sysstem and returns the last result (most recent registrar)
     * @param {String} signal to relay
     * @return {*} mixed
     */
    this.Answer     = function(signal) {
        var obj = this;
        var results = obj.Relay.apply(this,arguments);
        if ( results.length==0 )
            return undefined;
        var result = results.pop()
        return result;
    };

    /**
     * @alias Robots.Register
     */
    this.register   = function(signal, callback, description) {
        var obj = this;
        return this.Register.apply(obj,arguments);
    };

    /**
     * Registers a function to be called each time the signal is relayed
     * @param {String} signal to register
     * @param {Function} callback to call when the signal is relayed
     * @param {String} description of the callback being run for the signal
     * @return {Signal}
     */
    this.Register   = function(signal, callback, description) {
        var obj = this;
        if ( Array.isArray(signal) ) {
            for ( var i in signal )
                this.register(signal[i], callback);
            return;
        }
        if ( !Array.isArray(obj.Callbacks[signal]) )
            obj.Callbacks[signal]   = [];

        var cb = {'onetime':false,'fn':callback,'description': description};

        obj.Callbacks[signal].push(cb);

        obj.lastRegistration = [false, signal, obj.Callbacks[signal].length-1];

        obj.numRegistered++;
        return [signal,obj.Callbacks[signal].length-1,false];
    };

    /**
     * @alias Robots.Register
     */
    this.registerTest = function() {
        var obj = this;
        return this.RegisterTest.apply(obj,arguments);
    };

    /**
     * Registers a test to be called when the test runner loops
     * @param {String} signal to register
     * @param {Function} callback to call when the signal is relayed
     * @param {String} description of the callback being run for the signal
     * @return {Signal}
     */
    this.RegisterTest = function(signal, callback, description) {
        var obj = this;
        if ( Array.isArray(signal) ) {
            for ( var i in signal )
                this.register(signal[i], callback);
            return;
        }
        if ( !Array.isArray(obj.Tests[signal]) )
            obj.Tests[signal]   = [];

        var cb = {'fn':callback, 'description': description};

        obj.Tests[signal].push(cb);

        obj.numTests++;
        obj.testCoverage = obj.numTests / obj.numRegistered;
        return [signal,obj.Tests[signal].length-1,false];
    };

    /**
     * @alias Robots.RegisterTestIfNot
     */
    this.registerTestIfNot  = function(signal, callback) {
        return this.RegisterTestIfNot.apply(this, arguments);
    };

    /**
     * Registers only if the signal currently has no registrant
     * @param {String} signal to register
     * @param {Function} callback to call when the signal is relayed
     * @param {String} description of the callback being run for the signal
     * @return {Signal}
     */
     this.RegisterTestIfNot = function(signal, callback, description) {
        if (!this.Tests.hasOwnProperty(signal))
            return this.RegisterTest.apply(this, arguments);
        return null;
     };

    /**
     * Runs the registered tests
     * @param {Function} each (optional) function returns the test to be run
     */
    this.runTests = function(each) {
        var i, j, obj;

        obj = this;

        for (i in obj.Tests) {
            if (typeof each == 'undefined') {
                for (j in obj.Tests[i])
                    obj.Tests[i][j]['fn'].apply(obj);
            }
            else 
                for (j in obj.Tests[i])
                    each(i, obj.Tests[i][j]['fn'], obj.Tests[i][j]['description']);
        }
    };

    /**
     * @alias Robots.Echo
     */
    this.echo   = function(from, to) {
        var obj = this;
        this.Echo.apply(obj,arguments);
    }

    /**
     * bounces one signal to another
     * @param {String} from signal to source
     * @param {String} to signal to forward to
     */
    this.Echo   = function(from, to) {
        var obj = this;
        if ( arguments.length > 2 &amp;&amp; typeof arguments[2] == "function" )
            fn  = arguments[2];
        else
            fn  = function(){return true;}
        obj.register(signal, function(){
            args    = Array.prototype.slice.call(arguments,0);
            if ( !fn.apply(obj,args) )
                return;
            args.unshift(signal2);
            obj.relay.apply(obj,args);
        })
    };

    /**
     * @alias  Robots.RegisterLike
     */
    this.registerLike   = function(signalLike, cb) {

    };

    /**
     * Registers a function with a signal that contains the signalLike parameter.
     * This is useful for variable signals that may include an ID
     * @param {String}   signalLike signal to listen for
     * @param {Function} cb     callback to trigger 
     */
    this.RegisterLike   = function(signalLike, cb) {

    };

    /**
     * @alias Robots.RegisterIfNot
     */
    this.registerIfNot  = function(signal, callback) {
        return this.RegisterIfNot.apply(this, arguments);
    };

    /**
     * Registers only if the signal currently has no registrant
     * @param {String} signal to register
     * @param {Function} callback to call when the signal is relayed
     * @return {Signal}
     */
     this.RegisterIfNot = function(signal, callback) {
        if (!this.Callbacks.hasOwnProperty(signal))
            return this.Register.apply(this, arguments);
        return null;
     };

     /**
      * @alias Robots.AnswerAsync
      */
     this.answerAsync = function(signal) {
        var obj = this;
        return this.AnswerAsync.apply(obj,arguments);
     };

    /**
     * answers asynchronously such that when fn is called, it is filled with the
     * callback data's last result
     * @param {String} signal signal to relay
     * @param {Function} fn callback to be called and will be filled with the data
     * @return {Array&lt;Signal>} an array of signals
     */
    this.AnswerAsync = function(signal,fn){
        args    = Array.prototype.slice.call(arguments,0);
        fn  = args[args.length-1];
        if ( typeof fn != "function" )
            var fn      = function(){};
        else
            var fn      = args.pop();

        fnWrapper = function(r) {
            fn(r.pop());
        }
        var obj = this;
        var numCallbacks = this.callbackID;
        return this.finished(this.Relay.apply(obj,args), fnWrapper, numCallbacks);
    };

    /**
     * @alias Robots.RelayAsync
     */
    this.relayAsync = function(signal){
        var obj = this;
        return this.RelayAsync.apply(obj,arguments);
    };

    /**
     * Relays asynchronously such that when fn is called, it is filled with the
     * callback data
     * @param {String} signal signal to relay
     * @param {Function} fn callback to be called and will be filled with the data
     * @return {Array&lt;Signal>} an array of signals
     */
    this.RelayAsync = function(signal,fn){
        args    = Array.prototype.slice.call(arguments,0);
        fn  = args[args.length-1];
        if ( typeof fn != "function" )
            var fn      = function(){};
        else
            var fn      = args.pop();

        var obj = this;
        var numCallbacks = this.callbackID;
        return this.finished(this.Relay.apply(obj,args), fn, numCallbacks);
    };

    /**
     * @alias Robots.Relay
     */
    this.relay  = function(signal){
        var obj = this;
        return this.Relay.apply(obj,arguments);
    };

    /**
     * Relays a signal to the system, such that all listeners are called with the supplied data
     * @param {String} signal to relay to the systemm
     * @return {Array&lt;*>} an array filled with the return results of the callbacks
     */
    this.Relay  = function(signal) {
        var obj = this;
        if ( signal != 'robots-signal-relayed' )
            obj.relay('robots-signal-relayed', signal, Array.prototype.slice.call(arguments,1));

        if ( !Array.isArray(obj.Callbacks[signal]) &amp;&amp; !Array.isArray(obj.OnetimeCallbacks[signal]) )
            return [];

        var results = [];

        if ( Array.isArray(obj.OnetimeCallbacks[signal]) ) {
            var onetimes   = obj.OnetimeCallbacks[signal];
            while ( onetimes.length > 0 ) {
                var onetime = onetimes.pop();
                try {
                    this.currentSignal  = signal;
                    this.callbackID++;
                    results.push(onetime['fn'].apply(this,Array.prototype.slice.call(arguments,1)));
                } catch(e) {
                    console.log("Current signal: "+signal);
                    console.log(e);
                }
                obj.numRegistered--;
            }
        }

        if ( Array.isArray(obj.Callbacks[signal]) ) {
            var cbs = obj.Callbacks[signal];
            for ( var i in cbs ) {
                try {
                    this.currentSignal  = signal;
                    this.callbackID++;
                    results.push(cbs[i]['fn'].apply(this, Array.prototype.slice.call(arguments,1)));
                } catch(e) {
                    console.log("Current signal: "+signal);
                    console.log(e);
                }
            }
        }

        return results;
    };

    this.copy = function() {
        var obj;
        obj = new RobotsClass();

        obj.http        = new RobotsHTTP();
        obj.http.parent = function() { return obj; };
        obj.signals = new RobotsSignals();
        obj.signals.parent = function() { return obj; };
        obj.api         = new RobotsAPI();
        obj.api.parent  = function() { return obj; };

        obj.signals.readSignals();
        obj.api.initializeExpress();

        return obj;
    };

    return this;
});

module.Robots  = module.exports  = new RobotsClass();

if (configs['spiritbots'].hasOwnProperty('network') &amp;&amp;
    configs['spiritbots']['network']){
    
    module.Robots.http = new RobotsHTTP();
    module.Robots.http.parent   = function() { return module.Robots; };
    module.Robots.signals = new RobotsSignals();
    module.Robots.signals.parent = function() { return module.Robots; };
    module.Robots.api  = new RobotsAPI();
    module.Robots.api.parent    = function() { return module.Robots; };
    
    module.Robots.signals.readSignals();
    module.Robots.api.initializeExpress();

    module.exports  = module.Robots;
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-Spiritbots.html">Spiritbots</a></li><li><a href="robots-signals%2520scans%2520for%2520the%2520signals%2520directory%2520and%2520each%2520file_s%2520export%2520function%250Dbecomes%2520a%2520signal%2520with%2520the%2520filenamemodule_.html">robots-signals scans for the signals directory and each file's export functionbecomes a signal with the filename</a></li></ul><h3>Classes</h3><ul><li><a href="module-Spiritbots-Robots.html">Robots</a></li><li><a href="robots-signals%2520scans%2520for%2520the%2520signals%2520directory%2520and%2520each%2520file_s%2520export%2520function%250Dbecomes%2520a%2520signal%2520with%2520the%2520filenamemodule_-signals.html">signals</a></li><li><a href="RobotsAPI.html">RobotsAPI</a></li><li><a href="RobotsHTTP.html">RobotsHTTP</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Wed May 25 2016 09:27:32 GMT-0600 (Mountain Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
