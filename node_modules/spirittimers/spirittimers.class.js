'use strict';

/*
Todo's:
    * Have status file
    * Signal on time trigger, callback either direct or via signal
    * Status file shows last run iterator
    * Status file shows last run status
    * Status file shows last run timestamp
 */

/**
 * Manages timers executing on interval.  This is a singleton object.
 * @class
 */
class SpiritTimers {
    constructor() {
        // singleton pattern
        if (SpiritTimers.instance) {
            return SpiritTimers.instance;
        }
        SpiritTimers.instance = this;

        this.chalk = require('chalk');
        this.fs = require('fs');
        /**
         * Log of executions, stores timer keyed by timestamp.
         * @type {Object}
         */
        this.executionLog = {};
        /**
         * The number of timers currently created.
         * @type {Number}
         */
        this.numTimers = 0;
        this.spiritFiles = require('spiritfiles');
        this.spiritTimer = require(__dirname + '/spirittimer.class.js');

        /** @type {Object<string, SpiritTimer>} */
        this.timers = {};
        /** @type {Object<string, Array>} */
        this.timerIntervals = {};

        /**
         * This has to be run async.  readTimerFiles calls a stack to require
         * this file.
         */
        setTimeout(() => {
            this.readTimerFiles();
        });
        process.on('SpiritTests Setting Up Routes', 
            this.setupRoutes.bind(this));
    }

    /**
     * Wraps the creation of a new timer.
     */
    addTimer(callbackFn, interval) {
        let timer;
        if (typeof callbackFn != 'function') {
            console.log(this.chalk.red('SpiritTimers Error: ') + 'attempted' + 
                ' to create a timer without a function.');
        }
        timer = new this.spiritTimer(callbackFn, interval);
        this.addTimerToIntervalGroup(timer);
        return timer;
    }

    /**
     * Wraps the creation of a new timer and executes it.
     */
    addTimerAndExecute(callbackFn, interval) {
        let timer;
        timer = this.addTimer(callbackFn, interval);
        timer.execute();
        return timer;
    }

    /**
     * Calculates the best timer interval.  This boxes existing timers into
     *     fixed intervals to reduce the number of timers looped on each
     *     iteration.
     * @param {SpiritTimer} timer The timer to add to the interval group.
     */
    addTimerToIntervalGroup(timer) {
        let interval;
        interval = timer.getInterval();
        interval = SpiritTimers.toTimeString(interval);
        interval = SpiritTimers.parseTimeString(interval);
        if (!this.timers[interval]) {
            this.timers[interval] = {};
            this.createTimer(interval);
        }
        this.timers[interval][timer.getId()] =
            timer;
        this.numTimers++;
    }

    /**
     * Creates a timer, given a time string or a time (in ms).
     */
    createTimer(interval) {
        if (this.timerIntervals.hasOwnProperty(interval)) {
            clearInterval(this.timerIntervals[interval]);
            delete this.timerIntervals[interval];
        }
        this.timerIntervals[interval] = setInterval(this.
            createTimerCallback(interval),
            SpiritTimers.parseTimeInterval(interval));
    }

    /**
     * Creates a timer, and saves it to a file.
     * @param {Function} callbackFn Function called when the timer is triggered.
     * @param {Number} interval The interval to use for the timer.
     * @param {Boolean?} temporary (Optional) If true, timer is destroyed on
     * program exit.
     * @return {SpiritTimer} A Timer Object.
     */
    createTimerFile(callbackFn, interval, temporary) {
        let timer;
        timer = this.addTimer(callbackFn, interval);
        timer.save(temporary);
        return timer;
    }

    /**
     * Creates a timer callback.
     */
    createTimerCallback(interval) {
        let timer;
        if (typeof interval != 'string') {
            interval = SpiritTimers.toTimeString(interval);
        }
        return () => {
            for (timer in
                this.timers[interval]) {
                timer = this.timers[interval][timer];
                if (timer.shouldExecute()) {
                    timer.execute();
                }
            }
        };
    }

    /**
     * Like removeTimers, but also deletes any files associated with the timers.
     */
    deleteAllTimers() {
        let interval, timerId;
        for (interval in this.timers) {
            for (timerId in this.timers[interval]) {
                this.removeTimer(this.timers[interval][timerId], true);
            }
        }
    }

    /**
     * Returns all executed timers, and their counts.
     * @param  {number|string=} since (Optional) Only match executions since
     *     the provided time.  Accepts either a timestamp or time string.
     * @return {Array<SpiritTimer>} An array of timers.
     */
    executedTimers(since) {
        let timers, timestamp, timestamps;
        timers = [];
        // TODO, requires a read of the execution log from filesystem.
        timestamps = Object.keys(this.executionLog);
        timestamps.sort();
        for (timestamp of timestamps) {
            if (parseInt(timestamp) > since) {
                timers.push(this.executionLog[timestamp]);
            }
        }
        return timers;
    }

    /**
     * Executes a timer.  If the timer is
     * @param {SpiritTimer} timer The timer to execute.
     */
    executeTimer(timer) {
        if (timer.paused) {
            timer.resume();
        }
        timer.execute();
        this.logExecution(timer);
    }

    /**
     * Executes all timers.
     * @param {number|string=} until (Optional) Executes timers that only would
     *     be executed until the timestamp or time string provided.
     */
    executeTimers(until) {
        let interval, intervals, timer;
        let untilTimestamp;
        if (typeof until != 'string') {
            untilTimestamp = until;
            until = SpiritTimers.toTimeString(until);
        } else {
            untilTimestamp = SpiritTimers.parseTimestamp(until);
        }
        intervals = SpiritTimers.getIntervals(until);
        for (interval of intervals) {
            for (timer in this.timers[interval]) {
                timer = this.timers[interval][timer];
                if (timer.shouldExecute(untilTimestamp)) {
                    // then execute! :)
                    timer.execute(untilTimestamp);
                    this.logExecution(timer, timer.lastExecution + 
                        timer.interval);
                }
            }
        }
    }

    /**
     * Gets valid intervals given a timestamp or time string.  This is helpful
     * when wanting more than 1:1 translation, e.g. 1h == hourly, but also
     * knowing 1h == [hourly, by the minute, every second!].  Helper function
     * for traversal patterns.
     * @param  {string|number} interval Timestamp or time string.
     * @param  {boolean} before (Optional) If true, then returns intervals
     *     larger than the timestamp or time string provided.
     * @return {Array<string>} An array of valid intervals;
     */
    static getIntervals(interval, before) {
        const intervals = [
            'yearly',
            'monthly',
            'weekly',
            'daily',
            'hourly',
            'by the minute',
            'every second!'
        ];
        if (typeof interval != 'string') {
            interval = SpiritTimers.toTimeString(interval);
        }
        interval = SpiritTimers.parseTimeString(interval);
        if (!before) {
            return intervals.slice(intervals.indexOf(interval));
        } else {
            return intervals.slice(0, intervals.indexOf(interval));
        }
    }


    /**
     * Gets timer files.
     * @return {Array<string>} An array of timer files or false if the directory
     * does not exist.
     */
    getTimerFiles() {
        if (!this.fs.existsSync(process.cwd() + '/' + 'timers')) {
            return false;
        }
        return this.spiritFiles.readFiles('timers', this.readTimerFiles
            .bind(this), 1000 * 60);
    }

    /**
     * Logs the execution of a timer event.
     * @param {SpiritTimer} timer The timer being called.
     * @param {Number|string} timestamp (Optional) If provided, logs the
     *     execution at timestamp.
     */
    logExecution(timer, timestamp) {
        if (!timestamp) {
            timestamp = (new Date()).getTime();
        }
        this.executionLog[timestamp.toString()] = timer;
        if (this.shouldWriteExecutionLog()) {
            this.writeExecutionLog();
        }
    }

    /**
     * Parses a timestamp as a keyed interval.  This is a numeric value that
     *     can be used as an input to setInterval.
     * @param {number|string} interval A timestamp or time string.
     * @return {string} A key that can be used when indexing timers.
     */
    static parseTimeInterval(interval) {
        if (typeof interval != 'string') {
            interval = SpiritTimers.parseTimestamp(interval);
        }
        if (!interval) {
            return false;
        }
        if (interval.indexOf('yearly') != -1) {
            return 1000 * 60 * 60 * 24 * 365;
        } else if (interval.indexOf('monthly') != -1) {
            return 1000 * 60 * 60 * 24 * (365 / 12);
        } else if (interval.indexOf('weekly') != -1) {
            return 1000 * 60 * 60 * 24 * 7;
        } else if (interval.indexOf('daily') != -1) {
            return 1000 * 60 * 60 * 24;
        } else if (interval.indexOf('hourly') != -1) {
            return 1000 * 60 * 60;
        } else if (interval.indexOf('by the minute') != -1) {
            return 1000 * 60;
        } else if (interval.indexOf('every second!') != -1) {
            return 1000;
        }
    }

    /**
     * Parses time string into timestamp, e.g. 1w2d6h.
     * @param {string} [varname] [description]
     * @return {number} A timestamp.
     */
    static parseTimestamp(timeString) {
        let timestamp, timeStr;
        const day = 1000 * 60 * 60 * 24;
        if (typeof timeString != 'string') {
            return false;
        }
        timestamp = 0;
        let getNumberToken = (position) => {
            let numberToken = '';
            if (position == -1) {
                return false;
            }
            while (!isNaN(timeStr = timeString.substr(--position, 1))) {
                numberToken = timeStr + numberToken;
            }
            return numberToken;
        };
        const years = getNumberToken(timeString.indexOf('y'));
        const months = getNumberToken(timeString.indexOf('M'));
        const weeks = getNumberToken(timeString.indexOf('w'));
        const days = getNumberToken(timeString.indexOf('d'));
        const hours = getNumberToken(timeString.indexOf('h'));
        const minutes = getNumberToken(timeString.indexOf('m'));
        if (years) {
            timestamp += parseInt(years) * day * 365;
        }
        if (months) {
            timestamp += parseInt(months) * day * (365 / 12);
        }
        if (weeks) {
            timestamp += parseInt(weeks) * day * 7;
        }
        if (days) {
            timestamp += parseInt(days) * day;
        }
        if (hours) {
            timestamp += parseInt(hours) * 1000 * 60 * 60;
        }
        if (minutes) {
            timestamp += parseInt(minutes) * 1000 * 60;
        }

        return parseInt(timestamp);
    }

    /**
     * Parses a timestamp as a keyed string category.  This is used when
     *     indexing timers.
     * @param {number|string} interval A timestamp or time string.
     * @return {string} A key that can be used when indexing timers.
     */
    static parseTimeString(interval) {
        if (typeof interval != 'string') {
            interval = SpiritTimers.parseTimestamp(interval);
        }
        if (!interval) {
            return false;
        }
        if (interval.indexOf('y') != -1) {
            return 'yearly';
        } else if (interval.indexOf('M') != -1) {
            return 'monthly';
        } else if (interval.indexOf('w') != -1) {
            return 'weekly';
        } else if (interval.indexOf('d') != -1) {
            return 'daily';
        } else if (interval.indexOf('h') != -1) {
            return 'hourly';
        } else if (interval.indexOf('m') != -1) {
            return 'by the minute';
        } else if (interval.indexOf('s') != -1) {
            return 'every second!';
        }

        return false;
    }

    /**
     * Pauses all timers.
     */
    pauseAllTimers() {
        let interval;
        let id;
        for (interval in this.timers) {
            for (id in this.timers[interval]) {
                this.timers[interval][id].pause();
            }
        }
    }

    /**
     * Reads timer files, and instantiates a timer for each file.
     */
    readTimerFiles() {
        let file, files, timer;
        files = this.getTimerFiles();
        if (!files) {
            return false;
        }
        for (file of files) {
            if (file.endsWith('status.js')) {
                continue;
            }
            this.spiritTimer.fromFile(file);
        }
    }

    /**
     * Removes a timer, forever and ever.
     * @param {SpiritTimer} timer The timer object.
     * @param {Boolean} deleteFile (Optional) If true, deletes any associated timer and 
     *     status file.
     */
    removeTimer(timer, deleteFile) {
        let interval;
        interval = timer.getInterval();
        interval = SpiritTimers.toTimeString(interval);
        interval = SpiritTimers.parseTimeString(interval);
        if (this.timers.hasOwnProperty(interval) &&
            this.timers[interval].hasOwnProperty(timer.getId())) {
            delete this.timers[interval][timer.getId()];
            if (Object.keys(this.timers[interval]).length == 0) {
                delete this.timers[interval];
            }
        }
        if (deleteFile) {
            timer.remove();
        }
    }

    /**
     * Removes all the timers.
     */
    removeAllTimers() {
        let interval, timerId;
        for (interval in this.timers) {
            for (timerId in this.timers[interval]) {
                this.removeTimer(this.timers[interval][timerId]);
            }
        }
    }

    /**
     * Resumes all timers that were previously paused.
     */
    resumeAllTimers() {
        let interval;
        let id;
        for (interval in this.timers) {
            for (id in this.timers[interval]) {
                this.timers[interval][id].resume();
            }
        }
    }

    /**
     * Sets up routes for the timer API.
     */
    setupRoutes(app) {
        app.all('/spirittimers/list', function(req, res, next) {
            res.send(JSON.stringify(this.timers));
        }.bind(this));
    }

    /**
     * @return Returns true if the execution log exceeds memory threshold and
     * should be written to filesystem. 
     */
    shouldWriteExecutionLog() {
        // TODO, make this more exact?
        if (Object.keys(this.executionLog) > 1000) {
            return true;
        }
        return false;
    }

    /**
     * Parses a timestamp as a time string.
     * @param  {number} timestamp A timestamp.
     * @return {string} A time string, e.g. 1w2h5m.
     */
    static toTimeString(timestamp) {
        let years, months, weeks, days, hours, minutes, seconds, timeString;
        years = '';
        months = '';
        weeks = '';
        days = '';
        hours = '';
        minutes = '';
        seconds = '';

        if (!parseInt(timestamp) || isNaN(parseInt(timestamp))) {
            return timestamp;
        }

        const day = 1000 * 60 * 60 * 24;
        if (timestamp >= day * 365) {
            years = parseInt(timestamp / (day * 365)) + 'y';
            timestamp = timestamp % (day * 365);
        }
        if (timestamp >= day * (365 / 12)) {
            months = parseInt(timestamp / (day * (365 / 12))) + 'M';
            timestamp = timestamp % (day * (365 / 12));
        }
        if (timestamp >= day * 7) {
            weeks = parseInt(timestamp / (day * 7)) + 'w';
            timestamp = timestamp % (day * 7);
        }
        if (timestamp >= day) {
            days = parseInt(timestamp / day) + 'd';
            timestamp = timestamp % day;
        }
        if (timestamp >= 1000 * 60 * 60) {
            hours = parseInt(timestamp / (1000 * 60 * 60)) + 'h';
            timestamp = timestamp % (1000 * 60 * 60);
        }
        if (timestamp >= 1000 * 60) {
            minutes = parseInt(timestamp / (1000 * 60)) + 'm';
            timestamp = timestamp % (1000 * 60);
        }
        if (timestamp >= 1000) {
            seconds = parseInt(timestamp / (1000)) + 's';
            timestamp = timestamp % (1000);
        }
        timeString = years + months + weeks + days + hours + minutes + seconds;
        if (timestamp >= 0 && timeString.length == 0) {
            timeString = '1s';
        }

        return timeString;
    }

    /**
     * Writes the execution log from memory to the filesystem, storing the file
     * using the oldest timestamp and the newest timestamp, i.e.
     * 123456789-123456790.json.  Execution logs are stored in the cache and
     * flushed on process exit.
     */
    writeExecutionLog() {
        // TODO, actually write to filesystem.
        this.executionLog = {};
    }
}

module.exports = new SpiritTimers();
module.exports.class = SpiritTimers;