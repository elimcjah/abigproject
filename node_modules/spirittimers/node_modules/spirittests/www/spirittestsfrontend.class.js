class SpiritTestsFrontend {
    constructor() {
        let itv = setInterval(this.getUpdates.bind(this), 150);
        this.execute().then(() => {
            clearInterval(itv);
        });
    }

    /**
     * Clears the current tests.
     */
    clear() {
        $('.test:not(.hidden)').remove();
    }

    /**
     * Draws a spec, given a spec object.
     */
    drawSpec(parent, json) {
        let color, description, duration, message, specEl;
        specEl = $(parent).find('.spec.hidden').clone().get(0);
        color = json.passed ? 'success' : 'info';
        description = json.description;
        if (!json.hasOwnProperty('duration')) {
            duration = '';
        } else {
            duration = json.duration + 'ms';
        }
        if (json.errors) {
            color = 'danger';
        }
        message = json.passed ? 'Passed!' : json.errors ? 
            json.errors[0].message : 'Waiting';
        if (message.indexOf('DEFAULT_TIMEOUT_INTERVAL') != -1) {
            color = 'warning'; // might be developer error
        }
        $(specEl).removeClass('hidden');
        $(parent).find('tbody').append(specEl);
        specEl.outerHTML = Mustache.render(specEl.outerHTML, {
            statusColor: color,
            specDesc: description,
            specStatus: message,
            specDuration: duration
        });
    }

    /**
     * Draws the suite, which includes the specs and their statuses.
     */
    drawSuite(name, parent, json) {
        let datetime, suiteEl;
        suiteEl = $(parent).find('.suite.hidden').clone().get(0);
        for (let spec of json.specs) {
            this.drawSpec(suiteEl, spec);
        }
        $(suiteEl).removeClass('hidden');
        $(parent).find('.suites').append(suiteEl);
        suiteEl.outerHTML = Mustache.render(suiteEl.outerHTML, {
            suite: name
        });
        datetime = json.created;
        return datetime;
    }

    /**
     * Executes a new a test request, provided no test is currently executing.
     */
    execute() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: '/spirittests/execute',
                success: (xhrResult) => {
                    let latest, latestExecution;
                    latest = 0;
                    this.clear();
                    $('.loader').addClass('hidden');
                    for (let execution in xhrResult) {
                        if (xhrResult[execution].lastUpdated > latest) {
                            latest = xhrResult[execution].lastUpdated;
                            latestExecution = [execution, xhrResult[execution]];
                        }
                    }
                    this.drawExecution(latestExecution[0], latestExecution[1]);
                    resolve();
                }
            });
        });
    }

    /**
     * Hooks an interval to retrieve updates.
     * @return {Promise} A promise that resolves with the JSON data.
     */
    getUpdates() {
        return new Promise((resolve, reject) => {
            $.ajax({
                url: '/spirittests/getSuites',
                success: (xhrResult) => {
                    let latest, latestExecution;
                    latest = 0;
                    this.clear();
                    $('.loader').addClass('hidden');
                    for (let execution in xhrResult) {
                        if (xhrResult[execution].lastUpdated > latest) {
                            latest = xhrResult[execution].lastUpdated;
                            latestExecution = [execution, xhrResult[execution]];
                        }
                    }
                    this.drawExecution(latestExecution[0], latestExecution[1]);
                }
            });
        });
    }

    /**
     * Mock data available for testing without endpoints.
     */
    static mockData() {
        return {'SpiritConfigs Class':{'specs':[{'description':'Should scan configs in the process directory.','waiting':false,'duration':5,'passed':false,'errors':[{'matcherName':'','message':'Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.','stack':'Error: Timeout - Async callback was not invoked within timeout specified by jasmine.DEFAULT_TIMEOUT_INTERVAL.\n    at Timeout._onTimeout (C:\\spiritbots\\deployment\\production\\free\\spiritcore\\node_modules\\jasmine\\node_modules\\jasmine-core\\lib\\jasmine-core\\jasmine.js:1973:23)\n    at ontimeout (timers.js:365:14)\n    at tryOnTimeout (timers.js:237:5)\n    at Timer.listOnTimeout (timers.js:207:5)}'}]},{'description':'Should scan using a custom directory','waiting':false,'duration':5,'passed':true},{'description':'Should scan all modules and properly allow overrides.','waiting':true}]}};
    }

    /**
     * Turns JSON execution into DOM.
     * @param {String} name Name of the execution, usually a timestamp.
     * @param {String} execution JSON returned from server.
     */
    drawExecution(name, execution) {
        let datetime, suite, testEl;
        testEl = $('.test.hidden').clone().get(0);
        for (let suite in execution.suites) {
            datetime = this.drawSuite(suite, testEl, execution.suites[suite]);
        }
        $(testEl).removeClass('hidden');
        $('.tests').append(testEl);
        testEl.outerHTML = Mustache.render(testEl.outerHTML, {
            date:  new Date(datetime)
        });
    }

    /**
     * Saves a test result to the database.  Tests are best organized by date.
     * They can be optionally renamed.
     */
    saveResult() {
        $.ajax({
            url: 'http://development.lifebots.co/api.php/tests',
            data: {

            },
            type: 'post',
            success: function(s) {

            }
        });
    }
}