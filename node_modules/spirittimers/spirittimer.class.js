'use strict';

/**
 * @class
 * A SpiritTimer is typically loaded with a single iteration.
 */

console.log("yey");

class SpiritTimerIteration {
    constructor(name = '', numIterations = -1, ...args) {
        /**
         * The number of times this iteration has executed.
         */
        this.count = 0;

        /**
         * The name of the iteration.  By default, it is passed the name of the
         * timer.
         */
        this.name = name;

        /**
         * Arguments to use when calling the iteration.
         * @type {Array}
         */
        this.arguments = args;

        /**
         * The number of iterations to perform for this object.
         * @type {Number}
         */
        this.numIterations = numIterations;
    }
}

/**
 * @class
 * A timer status is saved on each iteration of a timer.
 */
class SpiritTimerStatus {
    constructor(returnValue, exceptions, iteration, timestamp, duration) {
        /**
         * An array of exceptions that occurred.
         * @type {Array}
         */
        this.exceptions = exceptions;
        /**
         * An array of exceptions that occurred.
         * @type {SpiritTimerIterable}
         */
        this.iteration = iteration;
        this.returnValue = returnValue;
        this.timestamp = timestamp;
        this.duration = duration;
    }
}

/**
 * A timer is a function that executes on a regular interval.  Timers have the
 * ehanced ability to function as a generator, whereby state is tracked and
 * incremented on each function call.
 * @class
 */
class SpiritTimer {
    /**
     * @param {Function} callbackFn The callback to call each time the timer is
     *     triggered.
     * @param {Number|String} interval The amount of milisecons between timer calls OR
     *     a string time (e.g. 1w2d5h).
     */
    constructor(callbackFn, interval) {
        /**
         * Arguments passed into the iteration.
         * @type {Array} 
         */
        this.arguments = [];
        this.bots = require('spiritbots');
        
        /**
         * The callback used by the timer.
         * @type {function()}
         */
        this.callbackFn = callbackFn;
        /**
         * The number of executions that have occurred for this timer.
         * @type {Number}
         */
        this.count = 0;

        /**
         * The current iteration.
         */
        this.currentIteration = new SpiritTimerIteration();

        /**
         * Filename of timer if.  Empty string if no file representation of
         * timer exists.
         * @type {String}
         */
        this.filename = '';

        this.files = require('spiritfiles');

        /**
         * A timestamp indicating the first execution.
         * @type {Number}
         */
        this.firstExecution = 0;

        this.fs = require('fs');

        /**
         * The string interval via SpiritTimers.toTimeString()
         * @type {string}
         */
        this.interval = interval;

        /**
         * The last execution timestamp.
         * @type {Number}
         */
        this.lastExecution = 0;

        /**
         * The last status of this timer.
         * @type {SpiritTimerIteration}
         */
        this.lastStatus = null;

        /**
         * The name of the timer.  This is either the ID or the filename.  If 
         * the timer is not read from a file, then the filenae is stored as
         * the ID.
         * @type {String}  
         */
        this.name = '';

        /**
         * If true, execution does not occur.
         * @type {Boolean}
         */
        this.paused = false;

        this.spirittimers = require(__dirname + '/spirittimers.class.js');

        /**
         * A unique identifier for this timer.
         * @type {string}
         */
        this.id = (new Date()).getTime() + '.' + interval + '.' + 
            this.spirittimers.numTimers;

        /**
         * Status object filled with SpiritTimerStatus objects.
         * @type {Object}
         */
        this.statuses = {};

        /** 
         * Status filename.
         * @type {String} 
         */
        this.statusFilename = '';

        /**
         * True if save function is called with temporary set to true.
         * @type {Boolean}
         */
        this.temporary = false;
    }

    /**
     * Creates a timer from a filename.
     * @return {SpiritTimer} A new timer, initialized via the file.
     */
    static fromFile(filename) {
        let fs, spirittimers, timer;
        fs = require('fs');
        spirittimers = require(__dirname + '/spirittimers.class.js');
        if (fs.existsSync(filename)) {
            timer = require(process.cwd() + '/' + filename);
            if (typeof timer.callbackFn == 'string') {
                try {
                    timer.callbackFn = eval(timer.callbackFn);
                } catch(e) {}
            }
            timer = spirittimers.addTimer(timer.callbackFn, timer.interval);
            timer.filename = filename;
        }
    }

    /**
     * Changes the interval for this timer.
     * @param {Number} to The interval to change this timer to.
     */
    changeInterval(to) {
        this.interval = to;
        this.spirittimers.removeTimer(this);
        this.spirittimers.addTimerToIntervalGroup(this);
    }

    /**
     * Clears the arguments.
     */
    clearArguments() {
        this.currentIteration.arguments = [];
    }

    /**
     * Executes the next timer iteration.
     * @param {Number|string} (Optional) If provided, timer executes at the 
     *     provided timestamp.
     */
    execute(timestamp) {
        let duration, exception, returnVal;
        if (!timestamp) {
            timestamp = (new Date()).getTime();
        }
        if (this.firstExecution == 0) {
            this.firstExecution = timestamp;
        }
        if (this.shouldExecute()) {
            try {
                returnVal = this.callbackFn.apply(this, this.getArguments());
            } catch(e) {
                exception = e;
            }
            duration = (new Date()).getTime() - timestamp;
            this.statuses[this.count] = new SpiritTimerStatus(returnVal, 
                exception, this.currentIteration, timestamp, duration);
            this.currentIteration.count++;
            this.count++;
        }

        this.lastExecution = timestamp;
        if (this.filename.length > 0) {
            // this.saveStatus();
        }

        this.bots.relay('spirittimer executed', this);
        this.bots.relay('spirittimer executed: ' + this.id, this);
    }

    /**
     * Gets the arguments using the current execution as input.
     * @return {Array} An array  of the arguments used.
     */
    getArguments() {
        return this.currentIteration.arguments;
    }

    /**
     *  Converts the timer into a string.
     * @return {String} A stringified version of the timer.
     */
    getFileContents() {
        return 'module.exports = ' + '{\n' +
            `   callbackFn: ${this.callbackFn},\n` + 
            `   id: '${this.getId()}',\n` + 
            `   interval: ${this.interval}\n` + 
            '}';
    }

    /**
     * Returns the ID of this timer.
     * @return {string} The ID of the timer.
     */
    getId() {
        return this.id;
    }

    /**
     * Gets the interval for this timer.
     * @return {number} The interval used by this timer.
     */
    getInterval() {
        return this.interval;
    }

    /**
     *  Converts the timer into a status string.
     * @return {String} A stringified version of the timer status.
     */
    getStatusFileContents() {
    }

    /**
     * Pauses the timer from executing.
     */
    pause() {
        this.paused = true;
    }

    /**
     * Stops the Timer from continued execution and removes the timer from
     * the filesystem, if it exists. 
     */
    remove() {
        this.pause();
        if (this.filename.length > 0 && 
            this.fs.existsSync(this.filename)) {
            this.fs.unlinkSync(this.filename);
        }
        if (this.statusFilename.length > 0 && 
            this.fs.existsSync(this.statusFilename)) {
            this.fs.unlinkSync(this.statusFilename);
        }
    }

    /**
     * Resumes the timer execution.
     */
    resume() {
        this.paused = false;
    }

    /**
     * Saves the current timer to the filesystem.
     * @param {Boolean} temporary If true, deletes the file on process exit.
     */
    save(temporary) {
        if (!this.fs.existsSync('timers')) {
            this.fs.mkdirSync('timers');
        }
        this.files.createLocalFile('timers', `${this.getId()}.js`,
            this.getFileContents(), temporary);
        this.temporary = true;
        this.filename = `timers/${this.getId()}.js`;
    }

    /**
     * Saves the status of the timer to a file.  This includes the last return
     * value, if any exceptions occurred, the iteration, and the time of
     * execution. 
     * @param {Boolean} temporary If true, file is deleted on program exit.
     */
    saveStatus(temporary) {
        this.files.createLocalFile('timers', `${this.getId()}.status.js`,
            this.getStatusFileContents(), temporary || this.temporary);
        this.statusFilename = `timers/${this.getId()}.status.js`;
    }

    /**
     * Schedules arguments used starting at startTime, ending at endTime.
     * This function creates a new iterable, and sets an expiration for the
     * current iterable.  If startTime is not set, it is set as the current
     * time.  If endTime is not set, it is set to -1 to never expire.
     * @param {Array} args The arguments array to use.
     * @param {Number} startTime A timestamp when to start this iteration.
     * @param {Number} endTime A timestamp when to end this iteration.
     */
    scheduleArguments(args, startTime, endTime) {

    }

    /**
     * Schedules arguments used starting at startTime, ending at endTime.
     * This function creates a new iterable, and sets an expiration for the
     * current iterable.  If startTime is not set, it is set as the current
     * time.  If endTime is not set, it is set to -1 to never expire.
     * 
     * Instead of providing an array, a function is instead called on each
     * iteration.
     * 
     * @param {Function:Array} fn The function to be called on each iteration.
     * @param {Number} startTime A timestamp when to start this iteration.
     * @param {Number} endTime A timestamp when to end this iteration.
     */
    scheduleArgumentsFunction(fn, startTime, endTime) {

    }

    /**
     * Schedules an execution at an arbitrary time.
     * @param {Number} timestamp The timestamp to schedule.
     */
    scheduleExecution(timestamp) {

    }

    /**
     * Sets the arguments used when calling the timer function.
     * @param {Array} args An Array of arguments.
     */
    setArguments(args) {
        this.currentIteration.arguments = args;
    }

    /**
     * Sets the function by which arguments are obtained.  This sets the
     * arguments of the current iteration.
     */
    setArgumentsFunction() {
        
    }

    /**
     * Sets the number of executions before this timer expires.  This is
     * computed using a combination of the interval time multiplied by the
     * desired number of executions.
     */
    setNumberOfExecutions() {

    }

    /**
     * Sets the value of the temporary status.
     */
    setTemporary(value) {

    }

    /**
     * Given an input time, determines if the timer should execute.
     * @param {Number|string} timestamp (Optional) If provided, evaluates 
     *     shouldExecute at the given time instead 
     * @return {boolean} True if the timer should execute.
     */
    shouldExecute(timestamp) {
        if (!timestamp) {
            timestamp = (new Date()).getTime();
        }
        if (!this.paused && 
            this.lastExecution + this.interval <= timestamp) {
            return true;
        }
        return false;
    }
}

module.exports = SpiritTimer;