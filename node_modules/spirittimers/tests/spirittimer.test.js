describe('SpiritTimer', () => {
    let bots, spirittimers, spirittimersClass;
    beforeEach(function() {
        bots = require('spiritbots');
        spirittimers = require(__dirname + '/../spirittimers.class.js');
        spirittimersClass = require(__dirname + '/../spirittimers.class.js').class;
    });

    it('Should allow a timer to be executed on-demand.', () => {
        let timer;
        let obj = {
            'fn': () => {

            }
        };
        spyOn(obj, 'fn').and.callThrough();
        timer = spirittimers.addTimer(obj.fn, 1000 * 60 * 60);
        spirittimers.executeTimer(timer);
        expect(obj.fn).toHaveBeenCalled();
    });

    it('Should properly record metrics about timer execution.', () => {
        let timer;
        let obj = {
            'fn': () => {

            }
        };
        spyOn(obj, 'fn').and.callThrough();
        timer = spirittimers.addTimer(obj.fn, 1000 * 60 * 60);
        expect(timer.firstExecution).toBe(0);
        expect(timer.count).toBe(0);
        spirittimers.executeTimer(timer);
        expect(timer.count).toBe(1);
        expect(Math.abs(timer.firstExecution - 
            (new Date()).getTime())).toBeLessThan(2000);
        expect(Math.abs(timer.lastExecution - 
            (new Date()).getTime())).toBeLessThan(2000);
        expect(obj.fn).toHaveBeenCalled();
    });

    it('Should remove a timer properly.', () => {
        let timer;
        let obj = {
            'fn': () => {

            }
        };
        expect(spirittimersClass.getIntervals(1000 * 60 * 60).length).toBe(3);
        timer = spirittimers.addTimer(obj.fn, 1000 * 60 * 60);
        expect(Object.keys(spirittimers.timers['hourly']).length).toBe(1);
        spirittimers.removeTimer(timer);
        expect(spirittimers.timers.hasOwnProperty('hourly'))
            .toBe(false);
    });

    it('Should create timers dynamically.', () => {
        let timer;
        let obj = {
            'fn': () => {
            }
        };
        timer = spirittimers.createTimerFile(obj.fn, 1000 * 60 * 60, true);
    });

    it('Should signal when the test is run.', (done) => {
        let timer;
        bots.register('spirittimer executed', () => {
            done();
        });
        timer = spirittimers.addTimer(() => {}, 1000);
        bots.register('spirittimer executed: ' + timer.id, () => {
            done();
        });
    });

    it('Should support timers being called with arguments.', () => {
        let timer;
        let arg = 0;
        let obj = {
            'fn': (arg1) => {
                arg = arg1;
            }
        };
        spyOn(obj, 'fn').and.callThrough();
        timer = spirittimers.addTimer(obj.fn, 1000 * 60 * 60);
        timer.setArguments([1]);
        spirittimers.executeTimer(timer);
        expect(obj.fn).toHaveBeenCalled();
        expect(arg).toBe(1);
    });

    it('Should save the return result of the last callback within the status.',
    () => {
        let timer;
        let arg = 0;
        let obj = {
            'fn': () => {
                return "THE STATUS";
            }
        };
        spyOn(obj, 'fn').and.callThrough();
        timer = spirittimers.addTimer(obj.fn, 1000 * 60 * 60);
        spirittimers.executeTimer(timer);
        expect(obj.fn).toHaveBeenCalled();
    });

    it('Should allow itertions to be skipped programmatically from' +
    ' the callback function.', () => {

    });

    afterEach(() => {
        spirittimers.removeAllTimers();
        process.emit('SpiritFiles Cleanup');
    });
});