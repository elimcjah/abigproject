<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";

class SpiritRScandir {
    constructor() {
        this.cacheFiles = {};
        this.chalk = require('chalk');
        this.fs = require('fs');
        this.readline = require('readline');
        this.rimraf = require('rimraf');
        this.hookShutdown();
    }

    /**
     * @param  {String} dir The directory string name to convert
     * @return {boolean} Returns true if the cache is invalidated by
     * an updated directory.
     */
    cacheInvalidated(dir) {
        let cacheMTime, dirMTime;
        dirMTime = (new Date(this.fs.lstatSync(dir).mtime)).getTime();
        if (!this.fs.existsSync('cache')) {
            return false;
        }
        if (!this.fs.existsSync('cache/' +
            this.convertDirToFilename(dir))) {
            return false;
        }
        cacheMTime = (new Date(this.fs.lstatSync('cache/' +
            this.convertDirToFilename(dir)).mtime)).getTime();
        return dirMTime > cacheMTime;
    }

    /**
     * Converts a directory to a filename, changing unusuable directory
     *     characters.
     * @param  {String} dir The directory string name to convert
     * @return {String} A standard string that can be used in a filename
     */
    convertDirToFilename(dir) {
        return dir.replace(/[/]/g, '_').replace(/[\.]/g, 'this') + '.json';
    }

    /**
     * @return {Boolean} Returns true if directory has unusable character.
     */
    hasUnusableCharacter(dir) {
        let unusable = (dir.search(/[\?\*\"\&lt;\>\|]/g) >= 0);
        unusable = unusable ||
            (dir.search(/[\:]/g) >= 0 &amp;&amp; dir.search(/[\:]/g) != 2)
        return unusable;
    }

    /**
     * Adds process hooks to listen when Node or the active process shuts down.
     */
    hookShutdown() {
        if (process.platform === "win32"){
            this.readline.createInterface ({
                input: process.stdin,
                output: process.stdout
            }).on ("SIGINT", () => {
                process.emit("SIGINT");
            });
        }
        // listen for TERM signal .e.g. kill
        process.on('SIGTERM', () => {this.onShutdown()});
        // listen for INT signal e.g. Ctrl-C
        process.on('SIGINT', () => {this.onShutdown()});
        process.on('exit', () => {this.onShutdown()});
        process.on('SpiritRScandir Cleanup', () => {this.onShutdown()});
    }

    /**
     * Removes cache files on shutdown.  If no files present in cache folder,
     * removes cache folders also.
     */
    onShutdown() {
        let directories = new Set();
        for (let file in this.cacheFiles) {
            if (this.fs.existsSync(file)) {
                this.fs.unlinkSync(file);
            }
            directories.add(this.cacheFiles[file]);
        }
        for (let cacheDir of directories) {
            if (SpiritRScandir.walkSync(cacheDir, [], true).length == 0) {
                this.rimraf.sync(cacheDir);
            }
        }
        this.cacheFiles = {};
    }

    /**
     * Reads a set of files from the cache.
     * @param  {String} dir The directory to look for.
     * @return {boolean|Array} An array of cached files or false if the cache
     *     is invalidated or does not exist.
     */
    readCache(dir) {
        let files = [];
        dir = this.convertDirToFilename(dir);
        if (!this.fs.existsSync('cache')) {
            return false;
        } else if (!this.fs.statSync('cache').isDirectory()) {
            console.log(this.chalk.yellow('SpiritRScandir warning: ') +
                ' cache is not a directory but a file!');
            return false;
        }
        if (this.fs.existsSync('cache/' + dir)) {
            try {
                files = JSON.parse(this.fs.readFileSync('cache/' + dir));
            } catch(e) {
                console.log(this.chalk.yellow('SpiritRScandir warning: ')
                    + 'JSON could not be parsed from cache.')
                files = false;
            }
            return files;
        }
    }

    /**
     * Recursively scans the directory.
     * @param  {String} dir the directory to scan
     * @param  {Array=} filelist An optional parameter used recursively.
     * @return {Array} A list of all files in dir
     */
    static walkSync(dir) {
        let filelist, files;
        if (object.hasUnusableCharacter(dir)) {
            console.warn(object.chalk.yellow('SpiritRScandir error: ') +
                'requested read with unusable directory name', dir);
            // return [];
        }
        files = object.readCache(dir);
        if (files &amp;&amp; !object.cacheInvalidated(dir)) {
            return files;
        }
        files = object.fs.readdirSync(dir);
        filelist = arguments[1] || [];
        files.forEach((file) => {
            if (object.fs.statSync(dir + '/' + file).isDirectory())
                filelist = SpiritRScandir.walkSync(dir + '/' + file,
                    filelist, true);
            else
                filelist.push(dir + '/' + file);
        });
        if (!arguments[2]) {
            object.writeCache(dir, filelist);
        }
        return filelist;
    }

    /**
     * Writes a set of files the cache for a directory
     * @param  {String} dir The directory to write for.
     */
    writeCache(dir, filelist) {
        dir = this.convertDirToFilename(dir);
        if (!this.fs.existsSync('cache')) {
            this.fs.mkdirSync('cache');
        }
        if (!this.fs.statSync('cache').isDirectory()) {
            console.log(this.chalk.yellow('SpiritRScandir warning: ') +
                ' cache is not a directory but a file!');
            return false;
        }
        this.fs.writeFileSync('./cache/' + dir, JSON.stringify(filelist));
        this.cacheFiles[process.cwd() + '/cache/' + dir] = process.cwd() +
            '/cache';
    }
}
let object = (new SpiritRScandir());
module.exports = SpiritRScandir.walkSync;</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.2</a> on Wed Oct 19 2016 09:59:07 GMT-0700 (Pacific Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
