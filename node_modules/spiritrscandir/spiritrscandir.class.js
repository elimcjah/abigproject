'use strict';

const SpiritRScandirSortStrategy = {
    'DEPTH_FIRST': 0,
    'ALPHABETICAL': 1
};

class SpiritRScandir {
    constructor() {
        if (SpiritRScandir.instance) {
            return SpiritRScandir.instance;
        }
        SpiritRScandir.instance = this;
        /** @type {Object} */
        this.cacheConfig = {};
        /** @type {Object} Either an object of filenames or of filelists. */
        this.cacheFiles = {};
        /** @type {Object} A hash of read times, used to invalidate a cache. */
        this.readTimestamps = {};
        this.chalk = require('chalk');
        this.fs = require('fs');
        this.readline = require('readline');
        this.rimraf = require('rimraf');
        this.scandir = require('scandir').create();
        this.wildstring = require('wildstring');

        this.hookShutdown();
        this.setCacheConfig();
        this.setSort(SpiritRScandirSortStrategy.DEPTH_FIRST);
    }

    /**
     * Reads directory entries stored in cache.
     * @param {boolean} useFilesystem If true, store cache results in filesystem
     *     and not memory.
     * @return {Promise} A promise when the read finishes.
     */
    batchRead() {
        let count, directories, resolveFn;
        count = 0;
        return new Promise((resolve) => {
            // reads in the rscandir cache of directories used last run
            // runs the async version of walk on each directory
            // after the last async run has finished, this should resolve
            try {
                directories = JSON.parse(this.fs.readFileSync(process.cwd() +
                    '/cache/spiritrscandir.json'));
            } catch(e) {
                directories = [];
            }
            resolveFn = (dir, files) => {
                this.cacheFiles[dir] = files;
                count++;
                if (count == directories.length) {
                    resolve();
                }
            }

            for (let dir of directories) {
                this.walk(dir).then((function(dir) {return (files) => {
                    resolveFn(dir, files);
                }})(dir));
            }
        });
    }

    /**
     * @param  {String} dir The directory string name to convert
     * @return {boolean} Returns true if the cache is invalidated by
     * an updated directory.
     */
    cacheInvalidated(dir) {
        if (this.readTimestamps[dir] &&
            this.readTimestamps[dir] + this.cacheConfig.expireTime <
            (new Date()).getTime()) {
            return true;
        }
        return false;
    }

    /**
     * Removes all cache files, or optionally removes files just for a
     * particular directory.
     * @param {string=} dir The directory name to remove the cache for
     *     (optional)
     */
    clearCache(dir) {
        if (this.cacheFiles[dir]) {
            if (typeof this.cacheFiles[dir] == 'string') {
                this.clearCacheFile(this.cacheFiles[dir]);
            }
            delete this.cacheFiles[dir];
        }
    }

    /**
     * Removes a particular cache file, given a named reference
     * @param  {string} cacheFile The file to remove.
     */
    clearCacheFile(cacheFile) {
        if (this.fs.existsSync(cacheFile)) {
            this.fs.unlinkSync(cacheFile);
        }
    }

    /**
     * Converts a directory to a filename, changing unusuable directory
     *     characters.
     * @param  {String} dir The directory string name to convert
     * @return {String} A standard string that can be used in a filename
     */
    convertDirToFilename(dir) {
        dir = dir.replace(/[/]/g, '_').replace(/[\.]/g, 'this') + '.json';
        if (dir.indexOf(process.cwd()) != -1) {
            dir = dir.substr(dir.indexOf(process.cwd().length));
        }
        return dir;
    }

    /**
     * @return {Boolean} Returns true if directory has unusable character.
     */
    hasUnusableCharacter(dir) {
        let unusable = (dir.search(/[\?\*\"\<\>\|]/g) >= 0);
        unusable = unusable ||
            (dir.search(/[\:]/g) >= 0 && dir.search(/[\:]/g) > 2)
        return unusable;
    }

    /**
     * Adds process hooks to listen when Node or the active process shuts down.
     */
    hookShutdown() {
        if (process.platform === 'win32') {
            this.readline.createInterface ({
                input: process.stdin,
                output: process.stdout
            }).on ('SIGINT', () => {
                process.emit('SIGINT');
            });
        }
        // listen for TERM signal .e.g. kill
        process.on('SIGTERM', () => {this.onShutdown();});
        // listen for INT signal e.g. Ctrl-C
        process.on('SIGINT', () => {this.onShutdown();});
        process.on('exit', () => {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        });
        process.on('SpiritRScandir Cleanup', () => {this.onShutdown();});
    }

    /**
     * Normalizes the directory name, removing leading slahes, forcing relative
     * directories.
     * @param  {string} dir The directory to normalize.
     * @return {string}     Normalized directory.
     */
    normalizeDirectoryName(dir) {
        if (dir.indexOf(process.cwd()) != -1) {
            dir = dir.substr(process.cwd().length);
        }
        if (dir.substr(0, 1) == '/') {
            dir = dir.substr(1);
        }
        if (SpiritRScandir.instance.hasUnusableCharacter(dir)) {
            console.warn(SpiritRScandir.instance.chalk.red('SpiritRScandir error: ') +
                'requested read with unusable directory name', dir);
        }
        return dir;
    }

    /**
     * Removes cache files on shutdown.  If no files present in cache folder,
     * removes cache folders also.
     */
    onShutdown() {
        let cacheDir, cacheRead, dir, directories, filename;
        directories = [];
        for (let dir in this.cacheFiles) {
            if (typeof this.cacheFiles[dir] != 'string') {
                continue;
            }
            filename = this.convertDirToFilename(dir);
            if (this.fs.existsSync(this.cacheFiles[dir] + '/' +
                filename)) {
                this.fs.unlinkSync(this.cacheFiles[dir] + '/' +
                filename);
            }
            directories.push([this.cacheFiles[dir], dir]);
        }
        for (dir of directories) {
            cacheDir = dir[0];
            dir = dir[1];
            cacheRead = SpiritRScandir.walkSync(cacheDir, null, true);
            if (cacheRead &&
                SpiritRScandir.walkSync(cacheDir, null, true)[0].length == 0) {
                this.rimraf.sync(cacheDir);
            }
            delete this.cacheFiles[dir];
        }
    }

    /**
     * Reads a set of files from the cache.
     * @param  {String} dir The directory to look for.
     * @return {boolean|Array} An array of cached files or false if the cache
     *     is invalidated or does not exist.
     */
    readCache(dir) {
        let files, filename;
        files = [];
        if (this.cacheFiles[dir] && typeof this.cacheFiles[dir] != 'string') {
            return this.cacheFiles[dir];
        }
        filename = this.convertDirToFilename(dir);
        if (!this.fs.existsSync('cache')) {
            return false;
        } else if (!this.fs.statSync('cache').isDirectory()) {
            console.log(this.chalk.yellow('SpiritRScandir warning: ') +
                ' cache is not a directory but a file!');
            return false;
        }
        if (this.fs.existsSync(process.cwd() + '/cache/' + filename)) {
            try {
                files = JSON.parse(this.fs.readFileSync(process.cwd() +
                    '/cache/' + filename));
            } catch(e) {
                console.log(this.chalk.yellow('SpiritRScandir warning: ')
                    + 'JSON could not be parsed from cache.')
                files = false;
            }
            return files;
        }
    }

    /**
     * Sets the cache config, using defaults when no arguments are provided.
     * @param {number} expireTime         [description]
     * @param {boolean} inMemory           [description]
     * @param {number} memoryThreshold    [description]
     * @param {number} numFilesThreshold  Number of files within a rscandir
     *     result before result must be stored in cache.
     * @param {number} recursionThreshold Number of recursions before a rscandir
     *     must be stored in cache.
     */
    setCacheConfig(expireTime,
        inMemory,
        memoryThreshold,
        numFilesThreshold,
        recursionThreshold) {
        this.cacheConfig.expireTime = expireTime ||
            SpiritRScandir.DEFAULT_CACHE_TIME;
        this.cacheConfig.inMemory = inMemory ||
            SpiritRScandir.DEFAULT_CACHE_INMEMORY;
        this.cacheConfig.memoryThreshold = memoryThreshold ||
            SpiritRScandir.DEFAULT_CACHE_MEMORY_THRESHOLD;
        this.cacheConfig.numFilesThreshold = numFilesThreshold ||
            SpiritRScandir.DEFAULT_CACHE_NUMFILES_THRESHOLD;
        this.cacheConfig.recursionThreshold = recursionThreshold ||
            SpiritRScandir.DEFAULT_CACHE_RECURSION_THRESHOLD;
    }

    /**
     * Sets the sort type.
     * @param {[type]} type [description]
     */
    setSort(type) {
        this.sort = type;
    }

    /**
     * Compares the current filelist and the number of recursions to the
     * current config options, returns a boolean if caching should automatically
     * occur.
     * @param  {Aray} filelist   A list of files given a rscandir.
     * @param  {number} recursions Number of recursions given a rscandir.
     * @return {boolean} True if the filelist should be cached.
     */
    shouldCache(filelist, recursions) {
        if (filelist.length > this.cacheConfig.numFilesThreshold) {
            return true;
        }
        if (recursions > this.cacheConfig.recursionThreshold) {
            return true;
        }
        return false;
    }

    /**
     * Asyncronous walk performed by the scandir NPM.
     * @param  {string} dir The directory being walked.
     * @return {Promise}     A promise that resolves with the files.
     */
    walk(dir) {
        let filelist = [];
        return new Promise((resolve) => {
            setTimeout(() => {
                resolve(SpiritRScandir.walkSync(dir));
            });
        });
    }

    /**
     * Walks directories recursively inside a folder.
     * @param  {String} dir The directory to scan.
     * @return {Array} A list of all directories in dir.
     */
    walkDirectoriesSync(dir) {
        let directories, file, files;
        directories = [];
        files = SpiritRScandir.walkSync(dir, null, null, true);
        for (file of files) {
            if (SpiritRScandir.instance.fs.statSync(file)
                .isDirectory()) {
                directories.push(file);
            }
        }

        return directories;
    }

    /**
     * Walks directories recursively inside a folder.  Filters using input
     * parameter which allows wildcards (denoted by * character).  If no
     * wildcard is used, then the trailing directory name is checked.
     * @param  {String} dir The directory to scan.
     * @param {String} filter A wilcard string or a search string.
     * @return {Array} A list of all directories in dir filtered by filter.
     */
    walkDirectoriesSyncAndFilter(dir, filter) {
        let directories, directory, filteredDirectories;
        directories = this.walkDirectoriesSync(dir);
        filteredDirectories = [];
        for (directory of directories) {
            if (this.wildstring.match(filter, directory)) {
                filteredDirectories.push(directory);
            } else if (!filter.includes('*')) {
                if (this.wildstring.match('*/' + filter, directory)) {
                    filteredDirectories.push(directory);
                } else if (filter == directory) {
                    filteredDirectories.push(directory);
                }
            }
        }

        return filteredDirectories;
    }

    /**
     * Recursively scans the directory.
     * @param  {String} dir The directory to scan
     * @param {String} filter A filter for minimatch.
     * @param  {boolean} recursion True if the function is currently in
     *     recursion.
     * @return {Array} A list of all files in dir.
     */
    static walkSync(dir, filter, recursion, includeDirectories) {
        let recursions, filelist, file, files, filteredFilelist, 
            nestedFilelist, result;
        recursions = 0;
        dir = SpiritRScandir.instance.normalizeDirectoryName(dir);
        if (!SpiritRScandir.instance.cacheInvalidated(dir)) {
            files = SpiritRScandir.instance.readCache(dir);
            if (files) {
                return files;
            }
        }
        if (!SpiritRScandir.instance.fs.existsSync(dir)) {
            console.warn(SpiritRScandir.instance.chalk.yellow('SpiritRScandir' +
                ' warning: ') + 'attempted to readdir that does not exist',
                dir);
            return false;
        }
        files = SpiritRScandir.instance.fs.readdirSync(dir);
        if (arguments[2]
            && SpiritRScandir.instance.sort ==
            SpiritRScandirSortStrategy.ALPHABETICAL) {
            filelist = arguments[2];
        } else {
            filelist = [];
        }
        nestedFilelist = [];
        files.forEach((file) => {
            if (SpiritRScandir.instance.fs.statSync(dir + '/' + file)
                .isDirectory()) {
                if (includeDirectories) {
                    filelist.push(dir + '/' + file);
                }
                result = SpiritRScandir.walkSync(dir + '/' + file, filter, 
                    filelist, includeDirectories);
                recursions += result[1];
                nestedFilelist = nestedFilelist.concat(result[0]);
                if (SpiritRScandir.instance.sort ==
                    SpiritRScandirSortStrategy.ALPHABETICAL) {
                    filelist = nestedFilelist;
                    nestedFilelist = [];
                }
            } else {
                filelist.push(dir + '/' + file);
            }
        });
        if (SpiritRScandir.instance.sort ==
            SpiritRScandirSortStrategy.DEPTH_FIRST) {
            filelist = nestedFilelist.concat(filelist);
        }

        if (filter) {
            filteredFilelist = [];
            for (file of filelist) {
                if (require('minimatch')(file, filter)) {
                    filteredFilelist.push(file);
                }
            }
            filelist = filteredFilelist;
        }

        if (!arguments[2]) {
            SpiritRScandir.instance.readTimestamps[dir] = (new Date())
                .getTime();
            SpiritRScandir.instance.writeCache(dir, filelist, recursions);
            return filelist;
        }
        return [filelist, recursions];
    }
    

    /**
     * Walks files recursively inside a folder.  Filters using input
     * parameter which allows wildcards (denoted by * character).  If no
     * wildcard is used, then the trailing filename is checked.
     * @param  {String} dir The directory to scan.
     * @param {String} filter A wilcard string or a search string.
     * @return {Array} A list of all files in dir filtered by filter.
     */
    walkSyncAndFilter(dir, filter) {
        let file, files, filteredFiles;
        files = SpiritRScandir.walkSync(dir);
        filteredFiles = [];
        for (file of files) {
            if (this.wildstring.match(filter, file)) {
                filteredFiles.push(file);
            } else if (!filter.includes('*')) {
                if (this.wildstring.match('*/' + filter, file)) {
                    filteredFiles.push(file);
                } else if (filter == file) {
                    filteredFiles.push(file);
                }
            }
        }

        return filteredFiles;
    }

    /**
     * Writes the directory cache, and also writes cache for results if
     * appropriate.
     * @param  {string} dir        Directory name.
     * @param  {Array} filelist    List of files.
     * @param  {number} recursions Number of subdirectories.
     */
    writeCache(dir, filelist, recursions) {
        let directories;
        if (!this.fs.existsSync(process.cwd() + '/cache')) {
            this.fs.mkdirSync(process.cwd() + '/cache');
        }
        if (!this.fs.statSync('cache').isDirectory()) {
            console.log(this.chalk.yellow('SpiritRScandir warning: ') +
                ' cache is not a directory but a file!');
            return false;
        }


        setTimeout(() => {
            try {
                directories = JSON.parse(this.fs.readFileSync(process.cwd() +
                    '/cache/spiritrscandir.json'));
            } catch(e) {
                directories = [];
            }
            if (directories.indexOf(dir) == -1) {
                directories.push(dir);
            }
            if (!this.fs.existsSync(process.cwd() + '/cache')) {
                this.fs.mkdirSync(process.cwd() + '/cache');
            }
            this.fs.writeFileSync(process.cwd() +
                    '/cache/spiritrscandir.json', JSON.stringify(directories));
        }, 10);

        if (this.shouldCache(filelist, recursions)) {
            console.log(this.chalk.cyan('Spiritrscandir info: ') + 'cache is ' +
                'being written to because you queried a large number of files' +
                ' or because you set your cacheConfig options.' +
                '  You should consider running a rscandir.batchRead on ' +
                'startup via:');
            console.log('**************************************');
            console.log(this.chalk.green('"(new (require(\'node_modules/spiritrscandir/spirit' +
                'rscandir.class.js\'))).batchRead();"'));
            console.log('**************************************');
            console.log('This will precache future rscandir reads and save ' +
                'on CPU resources.');
            this.writeFileCache(dir, filelist);
        }
    }

    /**
     * Writes the filelist to the cache so it can be speedily retrieved.
     * Writes either to memory or the filesystem, depending on options.
     * @param  {String} dir The directory to write for.
     * @param  {Array} filelist    List of files.
     */
    writeFileCache(dir, filelist) {
        let filename;

        if (this.cacheConfig.inMemory && this.cacheSize + filelist.length >
        this.cacheConfig.memoryThreshold) {
            this.cacheFiles[dir] = filelist;
            this.cacheSize += filelist.length;
            return;
        }
        filename = this.convertDirToFilename(dir);
        setTimeout(() => {
            this.fs.writeFileSync(process.cwd() + '/cache/' + filename,
                JSON.stringify(filelist));
            this.cacheFiles[dir] = process.cwd() +
                '/cache';
        }, 10);
    }
}

SpiritRScandir.DEFAULT_CACHE_TIME = 1000 * 60 * 60; // 1 hour
SpiritRScandir.DEFAULT_CACHE_INMEMORY = true;
SpiritRScandir.DEFAULT_CACHE_MEMORY_THRESHOLD = 500000; // or 5mb
SpiritRScandir.DEFAULT_CACHE_NUMFILES_THRESHOLD = 2000; // or ~200kb
SpiritRScandir.DEFAULT_CACHE_RECURSION_THRESHOLD = 75;
(new SpiritRScandir());
module.exports = {
    'SpiritRScandir': SpiritRScandir,
    'SpiritRScandirSortStrategy': SpiritRScandirSortStrategy
};