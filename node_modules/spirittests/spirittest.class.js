'use strict';

/**
 * @class Collects tests from the tests folder.  If a current test runner
 * exists, then test files are included via a requires statement.  If no test
 * runner exists, tests may be executed to yield a true/false result if the 
 * tests pass.
 */
class SpiritTests {
    constructor() {
        if (SpiritTests.instance) {
            return SpiritTests.instance;
        }
        /** @type {SpiritTests} Singleton instance */
        SpiritTests.instance = this;
        try {
            require('spiritconfigs/spiritconfigs.class.js')
                .setDefault('tests', {'ua-uuid': ''});
            this.configs = require('spiritconfigs/spiritconfigs.class.js')
                .readConfigs();
        } catch(e) {
            this.configs = null;
        }
        this.currentSuite = '';
        this.currentExecution = '';
        /** @type {Boolean} True if Jasmine is instantiated by SpiritTests. */
        this.customRunner = false;
        /** @type {Boolean} True if Jasmine is executing. */
        this.executing = false;
        /**
         * @type {Object} An object of suites that have ran, stored by
         * timestamp.
         */
        this.executions = {};
        try {
            this.files = require('spiritfiles');
        } catch(e) {
            this.files = null;
        }
        /** @type {Object} */
        this.fs = require('fs');
        this.intiialized = false;
        /** @type {Array} */
        this.promises = [];
        this.qs = require('querystring');
        this.request = require('request');
        /** @type {SpiritFiles} */
        this.spiritfiles = require('spiritfiles');
        this.spiritrscandir = require('spiritrscandir');
        /** @type {Object<string, Array>} */
        this.suites = {};
        /** @type {Array<string>} Array of files. */
        this.testFiles = [];
        /** @type {SpiritTestServer} */
        this.testServer = require('./spirittestserver.class.js');
        this.url = require('url');
        this.wildstring = require('wildstring');
        if (this.hasActiveTestRunner()) {
            this.currentExecution = (new Date()).toString();
            this.executing = true;
            this.initialize();
        } else {
            /** @type {Jasmine} */
            this.jasmine = this.getTestRunner();
            this.configureJasmine();
            this.customRunner = true;
            this.initialized = true;
        }
        process.on('SpiritTests Setting Up Routes', 
            this.setupRoutes.bind(this));
    }
    

    /**
     * Cleans up temporarily created files and configs.
     */
    cleanup() {
        this.cleanupConfigs();
        this.cleanupFiles();
    }

    /**
     * Cleans up the configs created temporarily.
     */
    cleanupConfigs() {
        process.emit('SpiritConfigs Cleanup');
    }

    /**
     * Cleans up the execution.
     */
    cleanupExecution() {
        this.executing = false;
        try {
            this.executions[this.currentExecution].lastUpdated = (new Date())
                .getTime();
        } catch(e) {

        }
        this.suites = {};
    }

    /**
     * Cleans up the files created temporarily.
     */
    cleanupFiles() {
        process.emit('SpiritFiles Cleanup');
    }

    /**
     * Configures Jasmine to utilize the existing tests.
     */
    configureJasmine() {
        // not thrilled, why not use a jasmine reporter instead of this hack?
        let completeFn = (passed) => {
            for (let suite in this.suites) {
                for (let spec of this.suites[suite].specs) {
                    if (spec.waiting && !spec.hasOwnProperty('passed')) {
                        spec.done.then(() => {
                            completeFn(true);
                        }).catch((e) => {
                            completeFn(e);
                        });
                        return;
                    }
                    if (!spec.hasOwnProperty('passed')) {
                        return; // waits for suite to finish, HACK
                    }
                }
            }
            let visit = require('universal-analytics')('UA-89117382-3', 
                this.configs['tests']['ua-uuid']);
            if (passed) {
                visit.event('Tests', 'Passed', 
                    this.configs['tests']['ua-uuid']);
            } else {
                visit.event('Tests', 'Failed', 
                    this.configs['tests']['ua-uuid']);
            }
            for (let suite in this.suites) {
                for (let spec of this.suites[suite].specs) {
                    if (spec.passed) {
                        visit.event('Tests-Passed', 
                            spec.description, 
                            this.configs['tests']['ua-uuid']).send();
                    } else {
                        visit.event('Tests-Failed', 
                            spec.description, 
                            this.configs['tests']['ua-uuid']).send();
                    }
                }
            }
            visit.send();
            this.cleanupExecution();
            setTimeout(() => {
                for (let promise of this.promises) {
                    if (passed) {
                        promise[0](passed);
                    } else {
                        promise[1](passed);
                    }
                }
                this.promises = [];
            }, 1500); // allow 1500ms for analytics to transmit
        };
        this.jasmine.completionReporter.onComplete(completeFn);
    }

    /**
     * Creates a config in the filesystem, and stores the created config for
     * later deletion.
     * @param {String} configName
     * @param {Object} contents
     * @return {Boolean} True if the file is created.
     */
    createConfig(configName, contents) {
        if (!this.configs) {
            return false;
        }
    }

    /**
     * Creates a file in the filesystem, and stores the created file for later
     * deletion.
     * @return {Boolean} True if the file is created.
     */
    createFile(filename, contents) {
        if (!this.files) {
            return false;
        }
        this.files.createLocalFile('', filename, contents, true);
        return true;
    }

    /**
     * Creates a test using the fn parameter.  Stores it in a file with an
     * optional name.  If no name is provided, then the file is automatically
     * named.  The test is temporary, so it is deleted on process exit.
     * @param {function} fn The function to create the test with.
     * @param {string} name (Optional) The filename to use.
     * @return {String} The name of the file created.
     */
    createTest(fn, name) {
        if (!name) {
            if (this.testFiles.length == 0) {
                this.readTests();
            }
            name = this.testFiles.length;
            while (this.fs.existsSync('tests/test' + name + '.js')) {
                name++;
            }
            name = 'test' + name + '.js';
        }
        fn = fn.toString();
        fn = fn.substr(fn.indexOf('{') + 1, 
            fn.length - fn.indexOf('{') - 
            (fn.length - fn.lastIndexOf('}') + 1));
        this.spiritfiles.createLocalFile('tests', name, fn, true);
    }

    /**
     * For each test, runs the tests inside the Jasmine test runner.  Produces
     * a result that is true/false.
     * @param {Boolean} silent If true, silences console output.
     * @return {Promise} A promise that resolves if the tests pass.
     */
    execute(silent) {
        let promise;
        if (this.executing) {
            return;
        }
        try {
            this.configs = require('spiritconfigs');
        } catch(e) {
            this.configs = null;            
        }
        this.readTests();
        promise = new Promise((resolve, reject) => {
            this.promises.push([resolve, reject]);
        });
        try {
            this.jasmine = this.getTestRunner(true);
            this.currentExecution = (new Date()).toString();
            this.executing = true;
            this.overrideJasmine();
            this.includeTests();
            this.configureJasmine();
            if (silent) {
                this.jasmine.env.clearReporters();
            }
            // this.jasmine.env.addReporter((new (require('jasmine/lib/reporters/console_reporter.js'))()));
            this.jasmine.execute(this.testFiles);
        } catch(e) {
            console.log(e);
        }
        return promise;
    }
    
    /**
     * Returns all it('Should...', statements for a given suite.
     * @param {String} suite A test suite.
     * @return {Array<String>} An Array of Statements.
     */
    getItStatements(suite) {
        return this.suites.hasOwnProperty(suite) ? this.suites[suite] : false;
    }

    /**
     * Returns Jasmine object.
     * @param {Boolean} forceNew If true, forces a new Jasmine object to be
     *     created.
     * @return {Jasmine} Jasmine object.
     */
    getTestRunner(force = false) {
        if (!force && global.hasOwnProperty('jasmine')) {
            return global.jasmine;
        } else {
            this.overriddenIt = null;
            this.overriddenDescribe = null;
            delete require.cache[require.resolve('jasmine')];
            return new (require('jasmine'))();
        }
    }

    /**
     * Gets all the test results.
     */
    getTestResults() {
        return this.suites;
    }

    /**
     * Gets all the named test suites.
     */
    getTestSuites() {
        return Object.keys(this.suites);
    }

    /**
     * @return {Boolean} True if active test runner.
     */
    hasActiveTestRunner() {
        return global.hasOwnProperty('jasmine');
    }

    /**
     * Includes tests found via readTests.
     */
    includeTests() {
        let file;
        if (this.testFiles.length == 0) {
            this.readTests();
        }
        for (file of this.testFiles) {
            delete require.cache[require.resolve(process.cwd() + '/' + file)];
            try {
                describe('SpiritTests test automatically loaded  from ' + 
                    file, () => {
                    require(process.cwd() + '/' + file);
                });
            } catch(e) {}
        }
    }

    /**
     * Initializes the test runner via inclusion or instantiation.
     */
    initialize() {
        if (this.initialized) {
            return;
        }
        this.initialized = true;
        /** @type {Jasmine} */
        this.jasmine = this.getTestRunner();
        this.overrideJasmine();
        this.includeTests();
        this.customRunner = false;
    }

    /**
     * Overrides the describe and it functions.
     */
    overrideJasmine() {
        var self = this;
        if (!this.overriddenIt) {
            this.overriddenIt = it;
        }
        it = (function(description, fn) {
            let fnWrapper, isAsync, spec, specMeta, suite, ts;
            if (!self.suites.hasOwnProperty(self.currentSuite)) {
                self.suites[this.currentSuite] = {
                    specs: [],
                    created: (new Date()).getTime(),
                    lastUpdated: (new Date()).getTime()
                };

                if (!self.executions.hasOwnProperty(self.currentExecution)) {
                    self.executions[self.currentExecution] = {
                        suites: {},
                        created: (new Date()).getTime(),
                        lastUpdated: (new Date()).getTime()
                    };
                }
                self.executions[self.currentExecution]
                    .suites[self.currentSuite] = self.suites[self.currentSuite];
            }
            suite = self.currentSuite.toString();
            spec = {};
            specMeta = {
                description: description,
                waiting: false
            }
            isAsync = fn.toString().indexOf('done') != -1 && 
                fn.toString().indexOf('done') < fn.toString().indexOf('{');
            // this is hacky but necessary, Jasmine toString's the fn
            if (isAsync) {
                fnWrapper = (function(done) {
                    ts = (new Date()).getTime();
                    specMeta.done = new Promise(function(resolve, reject) {
                        let completeFn = () => {
                            if (specMeta.hasOwnProperty('passed')) {
                                return;
                            }
                            specMeta.waiting = false;
                            specMeta.duration = (new Date()).getTime() - ts;
                            if (spec.result.failedExpectations.length > 0) {
                                specMeta.passed = false;
                                specMeta.errors = spec.result
                                    .failedExpectations;
                            } else {
                                specMeta.passed = true;
                            }
                            this.suites[suite].lastUpdated = 
                                (new Date()).getTime();
                            resolve();
                        }
                        // not thrilled, why not use a jasmine reporter?
                        let timer = setTimeout(completeFn.bind(this), 
                            jasmine.DEFAULT_TIMEOUT_INTERVAL + 1);
                        try {
                            fn.call(this.jasmine.env, () => {
                                setTimeout(() => {
                                    done();
                                    (completeFn.bind(this))();
                                });
                            });
                        } catch(e) {
                            reject(e);
                            throw e;
                        }
                    }.bind(self));
                    specMeta.waiting = true;
                }).bind(self);
            } else {
                fnWrapper = (function() {
                    ts = (new Date()).getTime();
                    try {
                        fn.apply(this.jasmine.env, arguments);
                    } catch(e) {
                        specMeta.duration = (new Date()).getTime() - ts;
                        specMeta.passed = false;
                        specMeta.errors = spec.result.failedExpectations;
                        this.suites[suite].lastUpdated = 
                            (new Date()).getTime();
                        throw e;
                    }
                    specMeta.duration = (new Date()).getTime() - ts;
                    if (spec.result.failedExpectations.length > 0) {
                        specMeta.passed = false;
                        specMeta.errors = spec.result.failedExpectations;
                    } else {
                        specMeta.passed = true;
                    }
                    this.suites[suite].lastUpdated = 
                        (new Date()).getTime();
                }).bind(self);
            }
            spec = self.overriddenIt.call(self.jasmine.env, 
                description, fnWrapper);
            self.suites[self.currentSuite].specs.push(specMeta);
        }).bind(this);
        if (!this.overriddenDescribe) {
            this.overriddenDescribe = describe;
        }
        describe = (function(description, fn) {
            let fnWrapper, previousSuite;
            previousSuite = this.currentSuite;
            fnWrapper = (function() {
                this.currentSuite = description;
                fn();
                this.currentSuite = previousSuite;
            }).bind(this);
            this.overriddenDescribe.call(this.jasmine.env, description, 
                fnWrapper);
        }).bind(this);
    }

    /**
     * Tests an endpoint with a ping.
     * @return {Promise} A promise that resolves if the endpoint is available.
     * Rejects if the endpoint is unavailable.
     */
    pingEndpoint(host, timeout) {
        return new Promise((resolve, reject) => {
            if (!this.bots) {
                reject();
            }
            this.bots.answerAsync('ping', host, 
                (latency) => {
                    if (latency < timeout) {
                        resolve();
                    } else {
                        reject();
                    }
                });
        });
    }

    /**
     * Reads the tests from the tests folder.
     */
    readTests() {
        let files, folder, folders;
        folders = [];
        if (this.configs.hasOwnProperty('tests')) {
            if (this.configs['tests'].hasOwnProperty('folders')) {
                folders = folders.concat(this.configs['tests']['folders']);
            }
        }
        this.testFiles = this.spiritfiles.readLocalFiles('tests');
        for (folder of folders) {
            if (files = this.spiritrscandir(folder, '**/*.js')) {
                this.testFiles = this.testFiles.concat(files);
            }
        }
        files = [];
        if (this.configs.hasOwnProperty('tests')) {
            if (this.configs['tests'].hasOwnProperty('files')) {
                this.testFiles = this.testFiles.concat(
                    this.configs['tests']['files']);
            }
        }
    }

    /**
     * Sets up the routes used by the SpiritTests module.
     */
    setupRoutes(app) {
        app.use('/spirittests/isExecuting', (function(req, res, next) {
            res.send(this.executing);
        }).bind(this));
        app.use('/spirittests/getSuites', (function(req, res, next) {
            res.send(this.executions);
        }).bind(this));
        app.use('/spirittests/execute', (function(req, res, next) {
            if (this.executing) {
                res.send(false);
                return;
            }
            this.execute(true).then((passed) => {
                res.send(this.executions);
            }).catch((e) => {
                res.send(this.executions);
            });
        }).bind(this));
    }

    /**
     * Tests an endpoint.
     * @param {Object} options An object that can contain a host, method, path,
     * and arguments.
     * @param {String} expects A wildcard enabled string that output is tested
     * against.
     * @return {Promise} A promise that resolves if the endpoint is available
     * and the return results from the request match the expects parameter.
     * Rejects if the endpoint is unavailable or the return results do not
     * match.
     */
    testEndpoint(options, expects) {
        let host, requestOptions, url;

        if (!expects) {
            expects = '*';
        }
        
        options = Object.assign({
            arguments: {},
            host: '',
            method: 'GET',
            path: '',
            request: {}
        }, options);

        url = this.url.parse(options.host);
        if (!url.path) {
            url.path = options.path;
        }

        options.method = options.method.toLowerCase();
        requestOptions = options.request;

        if (options.method == 'delete' || options.method == 'get') {
            url.query = this.qs.stringify(options.arguments);
        } else {
            requestOptions.body = options.arguments;
            requestOptions.json = true;
        }
        
        requestOptions = Object.assign(requestOptions, {
            'method': options.method,
            'url': url
        });

        return new Promise((resolve, reject) => {
            this.request(requestOptions, (err, res, body) => {
                if (err) {
                    reject(err);
                }
                if (this.wildstring.match(expects, body)) {
                    resolve(body);
                } else {
                    reject(false);
                }
            });
        });
    }
}

module.exports = new SpiritTests();