/**
 * @class SpiritDependencies
 * Object to manage dependencies such that NPM modules can be managed separately
 * and then merged into a single package.
 */
class SpiritDependencies {
    constructor() {
        if (!SpiritDependencies.instance) {
            SpiritDependencies.instance = this;
        } else {
            SpiritDependencies.instance.configs = require('spiritconfigs');
            return SpiritDependencies.instance;
        }
        this.chalk = require('chalk');
        this.cheerio = require('cheerio');
        this.configs = require('spiritconfigs');
        this.configHelpers = require('spiritconfigs/spiritconfigs.class.js');
        this.configHelpers.setDefault('dependencies', {
            'modules_folder': 'modules',
            'modules': [],
            'verbose': false
        });
        this.files = require('spiritfiles');
        this.fs = require('fs');
        this.npmCheck = require('npm-check');
        this.request = require('request');
        this.rimraf = require('rimraf');
        this.status = {
            in: 0,
            out: 0
        };

        process.on('SpiritTests Setting Up Routes', 
            this.setupRoutes.bind(this));

        this.visit = require('universal-analytics')(
            this.configs['dependencies']['ua-id'], 
            this.configs['dependencies']['ua-uuid']);
    }

    /**
     * Gets the absolute paths for modules.
     * @return {Object} An object of module paths, keyed by package name.
     */
    allModuleFolders() {
        let folders = {};
        if (!this.configs['dependencies'] || 
            !this.configs['dependencies']['modules']) {
            console.warn(this.chalk.yellow('SpiritDependencies warning: '),
                'Could not find modules to read, dumping configs.',
                this.configs, process.cwd());
        }
        for (let module of this.configs['dependencies']['modules']) {
            let folder = '';
            let packageName = '';
            if (typeof module == 'object') {
                folder = module[Object.keys(module)[0]];
                packageName = Object.keys(module)[0];
            } else {
                folder = module;
                packageName = folder;
            }
            if (!this.fs.existsSync(process.cwd() + '/' +
                this.configs['dependencies']['modules_folder'] + '/' + 
                folder)) {
                    console.warn(this.chalk.yellow('SpiritDependencies ' + 
                        'Warning: ') + 'Returning a module folder that does ' + 
                        'not exist! SpiritDependencies.allModuleFolders', 
                        packageName);
                }
            folders[packageName] = process.cwd() + '/' +
                this.configs['dependencies']['modules_folder'] + '/' + folder;
        }

        if (!Object.keys(folders).length) {
            console.warn(this.chalk.yellow('SpiritDependencies warning: '),
                'Found no modules, are there supposed to be modules defined?');
        }

        return folders;
    }

    /**
     * Returns all package.json contents of the modules, keyed by package.
     * @return {Object} An object of package files.
     */
    allPackageJSON() {
        let folders = this.allModuleFolders();
        let packageJSON = {};
        for (let packageName in folders) {
            try {
                packageJSON[packageName] = JSON.parse(this.fs.readFileSync(
                    folders[packageName] + '/package.json', 'UTF8'));
            } catch(e) {

            }
        }

        return packageJSON;
    }
    
    /**
     * Builds the package JSON file using all the modules dependencies.
     */
    buildPackageJSON() {
        let packages = this.allPackageJSON();
        let dependencies = {};
        for (let packageName in packages) {
            try {
                for (let dependency in packages[packageName]['dependencies']) {
                    let dependencyIsModule =
                        this.configs['dependencies']['modules']
                            .some((module) => {
                                if (typeof module == 'string' && 
                                    module == dependency) {
                                    return true;
                                }
                                if (typeof module == 'object' && 
                                    Object.keys(module)[0] == dependency) {
                                        return true;
                                    }
                                return false;
                            });
                    if (dependencyIsModule) {
                        continue;
                    }
                    dependencies[dependency] = 
                        packages[packageName]['dependencies'][dependency];
                }
            } catch(e) {

            }
        }

        try {
            let packageJSON = JSON.parse(this.fs.readFileSync(
                this.files.getApplicationDirectory() + '/package.json', 
                'UTF8'));
            packageJSON['dependencies'] = Object.assign(
                packageJSON['dependencies'], dependencies);
            this.fs.writeFileSync(
                this.files.getApplicationDirectory() + '/package.json',
                JSON.stringify(packageJSON, null, 2));
        } catch(e) {
            console.warn(this.chalk.yellow('SpiritDependencies Warning: ') + 
                'Failed to install package dependencies.', e);
        }
    }

    /**
     * Compares two particular versions, and returns a format similar to a 
     * strcmp (1 is gt, 0 is eq, -1 is lt).
     * @param {String} version A semver string.
     * @param {String} otherVersion A semver string.
     * @returns {Number} 1 is gt, 0 is eq, -1 is lt.
     */
    compareVersions(version, otherVersion) {
        version = parseInt('1' + version.split('.').reduce((acc, val) => {
            return acc + parseInt(('000' + val).slice(-'000'.length));
        }, ''));
        otherVersion = parseInt('1' + otherVersion.split('.').reduce((acc, val) => {
            return acc + parseInt(('000' + val).slice(-'000'.length));
        }, ''));
        if (version > otherVersion) {
            return 1;
        } else if (version == otherVersion) {
            return 0;
        } else {
            return -1;
        }
    }

    /**
     * Scans the configs for the packageName, and returns the local module name
     * if it exists.
     * @param {String} packageName The package name.
     * @returns {String} The module alias name if it exists.
     */
    getModuleAlias(packageName) {
        for (let module of this.configs['dependencies']['modules']) {
            if (typeof module == 'object') {
                if (packageName == Object.keys(module)[0]) {
                    return module[Object.keys(module)[0]];
                }
            }
        }
        return packageName;
    }

    /**
     * Installs all the dependencies for all the modules.
     */
    installAllDependencies() {
        let packages = this.allModuleFolders();
        for (let packageName in packages) {
            this.installDependencies(packageName);
        }
    }

    /**
     * Installs the dependencies listed for a package.  This is particularly
     * useful if a package is outside the node_modules folder.
     * @param {String} packageName The package to install modules for.
     */
    installDependencies(packageName) {
        let path = this.packagePath(packageName);
        try {
            if (!this.fs.existsSync(path)) {
                console.warn(this.chalk.yellow('SpiritDependencies ' + 
                    'Warning: ') + 'Attempting to install dependencies ' + 
                    'from a nonexistent folder.', path);
                return;
            }
            let packageJSON = 
                JSON.parse(this.fs.readFileSync(path + '/package.json', 'UTF8'));
            for (let dependency in packageJSON['dependencies']) {
                let cwd = process.cwd();
                process.chdir(this.files.getApplicationDirectory());
                if (this.fs.existsSync('./node_modules/' + dependency)) {
                    continue;
                }
                try {
                    console.info(this.chalk.cyan('SpiritDependencies Info: ') + 
                        'Installing ' + dependency);
                    require('child_process').execSync('npm cache clean');
                    require('child_process').execSync('npm install ' + 
                        dependency);
                } catch(e) {
                    if (this.configs['dependencies']['verbose']) {
                        console.warn(this.chalk.yellow('SpiritDependencies ' + 
                            'Warning: ') + 'There was some problem installing ' + 
                            dependency + ' for ' + packageName, e);
                    }
                }
                process.chdir(cwd);
            }
        } catch(e) {
            console.warn(this.chalk.yellow('SpiritDependencies ' + 
                'Warning: ') + 'There was some problem finding package.json ' + 
                ' for ' + packageName);
        }
    }

    /**
     * Checks if a package has the latest version or not.
     * @param {String} packageName The current package name to check.
     * @return {Promise} A promise that resolves when the result has been
     * determined.
     */
    isLatestVersion(packageName, includeModulesFolder = false) {
        return new Promise((resolve, reject) => {
            if (!this.fs.existsSync(this.modulesFolder() + packageName) 
                && !includeModulesFolder) {
                resolve(false);
            }
            if (!this.fs.existsSync(this.modulesFolder() + packageName) 
                && includeModulesFolder && 
                !this.fs.existsSync(this.files.getApplicationDirectory() + '/' + 
                    this.configs['dependencies']['modules_folder'] + '/' + 
                    this.getModuleAlias(packageName))) {
                resolve(false);
            }
            this.latestVersion(packageName).then((pkg) => {
                try {
                    if (this.compareVersions(pkg.latestVersion, 
                        this.packageVersion(packageName)) == 1) {
                        resolve(false);
                    } else {
                        resolve(true);
                    }
                } catch(e) {
                    resolve(false);
                }
            }).catch((e) => {
                console.warn(this.chalk.yellow
                    ('SpiritDependencies warning: '), 'an unexpected ' +
                    'error occurred: ', e);
            });
        });
    }

    /**
     * Gets the latest version of a module.
     * @param {String} packageName The name of the package.
     * @return {Promise} A promise that resolves with the latest information
     * about the package.
     */
    latestVersion(packageName) {
        let pkg = {};
        return new Promise((resolve, reject) => {
            this.request('https://www.npmjs.com/package/' + packageName, 
                (err, response, body) => {
                    if (err) {
                        reject(err);
                    }
                    let $ = this.cheerio.load(body);
                    pkg.description = $('.package-description').text()
                        .trim();
                    pkg.downloads = $('.pretty-number.monthly' + 
                        '-downloads').text().trim();
                    pkg.issues = $('#issues').text()
                        .trim();
                    // https://api.github.com/repos/cheeriojs/cheerio/pulls?per_page=1
                    // https://api.github.com/repos/cheeriojs/cheerio/issues?per_page=1
                    pkg.pullRequests = $('#pull_requests').text()
                        .trim();
                    pkg.lastPublisher = $('.last-publisher a').text()
                        .trim();
                    pkg.latestVersion = $('.last-publisher').next()
                        .children('strong').text()
                        .trim();
                    pkg.lastPublisherImg = $('.last-publisher img')
                        .attr('src');
                    pkg.lastPublished = $('.last-publisher>span')
                        .text().trim();
                    resolve(pkg);
                });
        });
    }

    /**
     * Minifies the JS files inside a package.  This can be used for 
     * obfuscation purposes.
     * @param {String} packageName The package name to minify.
     * @returns {Promise} A promise that resolves when the files are minified.
     */
    minifyJSFiles(packageName) {
        this.files.rscandir()
    }

    /**
     * Returns the most appropriate node_modules folder for the given 
     * process.cwd().
     * @returns {String} The least nested node_modules folder.
     */
    modulesFolder() {
        return this.files.getApplicationDirectory() + '/node_modules/';
    }

    /**
     * Returns the most appropriate node_modules folder for the given 
     * process.cwd().
     * @returns {String} The least nested node_modules folder.
     */
    static modulesFolder() {
        return require('spiritfiles').getApplicationDirectory() + '/node_modules/';
    }

    /**
     * Move all files from selected modules to their equivalent local modules
     * folder.  Once the modules have been moved, the node_modules folder is
     * symlink'd to the local modules folder.
     * @return {Promise} A promise that resolves when all modules have been
     * moved.
     */
    moveModules(modules = []) {
        if (modules.length == 0) {
            modules = this.configs['dependencies']['modules'];
        }
        // TODO: allow configuration of the modules_folder as a parameter
        let time = (new Date()).getTime();
        return new Promise((resolve, reject) => {
            let newModuleName;
            if (this.status.in > 0 || this.status.out > 0) {
                reject();
            }
            for (let module of modules) {
                if (typeof module == 'object') {
                    newModuleName = module[Object.keys(module)[0]];
                    module = Object.keys(module)[0];
                } else {
                    newModuleName = module;
                }
                if (!this.fs.existsSync('./node_modules/' + module)) {
                    if (this.fs.existsSync(this.configs['dependencies']
                        ['modules_folder'] + '/' + newModuleName)) {
                        this.symlinkModule(module, newModuleName);
                    }
                    continue;
                }
                try {
                    if (this.fs.lstatSync('./node_modules/' + module)
                        .isSymbolicLink()) {
                        continue;
                    }
                } catch(e) {}
                this.status.in++;
                console.info(this.chalk.cyan('SpiritDependencies info: ') + 
                    ' moving modules for', module,
                    '->', newModuleName);
                (function(module, newModuleName) {
                new Promise((resolve, reject) => {
                    if (!this.fs.existsSync('./node_modules/' + module)) {
                        resolve();
                    } else {
                        this.moveModule(module, newModuleName).then(resolve)
                            .catch(reject);
                    }
                }).then(() => {
                    this.movingModule = true;
                    console.info(this.chalk.cyan('SpiritDependencies info: ') + 
                        'migrating node_modules ' +
                        ' for', module, '->', newModuleName);
                    this.moveNodeModules(module, newModuleName).then(() => {
                        console.info(this.chalk.cyan('SpiritDependencies ' + 
                            'info: ') + 'symlinking ' +
                            ' for', module, '->', newModuleName);
                        this.symlinkModule(module, newModuleName);
                        this.status.out++;
                        this.movingModule = false;
                        console.info(this.chalk.cyan('SpiritDependencies ' + 
                            'info: ') + 'finished moving ' +
                            'module', module, '->', newModuleName);
                        if (this.status.out >= this.status.in) {
                            this.visit.event('Moving Modules', 
                                this.status.out, this.configs['dependencies']
                                ['ua-uuid'], 
                                parseInt((new Date()).getTime() - time)).send();
                            this.status.in = 0;
                            this.status.out = 0;
                            resolve();
                        }
                    }).catch((e) => {
                        if (this.configs['dependencies']['verbose']) {
                            console.warn(this.chalk.red('SpiritDependencies ' + 
                                'warning: ') + ' an error ' + 
                                'occurred moving node_modules', e, module, 
                                newModuleName);
                        }
                        this.movingModule = false;
                        this.status.out++;
                    });;
                }).catch((e) => {
                    if (this.configs['dependencies']['verbose']) {
                        console.warn(this.chalk.red('SpiritDependencies ' + 
                            'warning: ') + 'an error occurred' + 
                            ' moving modules', e, module, newModuleName);
                    }
                    this.movingModule = false;
                    this.status.out++;
                });
                this.movingModule = true;
                }).bind(this)(module, newModuleName);
            }
            if (this.status.in == 0) {
                resolve();
            }
        });
    }

    /**
     * Moves individual module from the node_modules folder to the
     * newModuleName folder.
     * @return {Promise} A promise that resolves when a single module is moved.
     */
    moveModule(module, newModuleName) {
        let existingFiles, files, stat;
        if (this.movingModule) {
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.moveModule.apply(this, arguments).
                        then(resolve).
                        catch(reject);
                }, 1);
            });
        }
        if (!this.configs['dependencies']['preserveChanges'] && 
            this.fs.existsSync(this.configs['dependencies']['modules_folder'] + 
            '/' + newModuleName)) {
                this.rimraf.sync(this.configs['dependencies']
                    ['modules_folder'] + '/' + 
                    newModuleName);
            }
        if (this.configs['dependencies']['preserveChanges']) {
            existingFiles = this.files.rscandir(this.configs['dependencies']
                ['modules_folder'] + '/' + newModuleName);
            files = this.files.rscandir('./node_modules/' + module);
            if (files) {
                for (let file of files) {
                    file = file.replace(/\\/g, '/');
                    // for each of the files to be moved
                    let path = file.substr(file.indexOf('node_modules/' + 
                        module) + ('node_modules/' + module).length);
                    if (!this.fs.existsSync(this.configs['dependencies']
                        ['modules_folder'] + '/' + newModuleName + path)) {
                            let stat;
                            // if the file DNE
                            this.files.fsExtra.mkdirsSync(this.configs
                                ['dependencies']['modules_folder'] + '/' + 
                                newModuleName + path.split('/').slice(0, -1).
                                join('/'));
                            this.files.fsExtra.copySync(file, this.configs
                                ['dependencies']['modules_folder'] + '/' + 
                                newModuleName + path, {
                                });
                    } else {
                        // if the mtime == ctime for the dest file
                        let stat;
                        stat = this.fs.lstatSync(this.configs['dependencies']
                            ['modules_folder'] + '/' + newModuleName + path);
                        console.info('SpiritDependencies Experimental: ' +
                            path, 'MTime: ' + stat.mtime.getTime(), 'BirthTime: ' + 
                            stat.birthtime.getTime(), 'Diff: ' +
                            Math.abs(stat.mtime.getTime() - stat.birthtime
                                .getTime()));
                        if (Math.abs(stat.mtime.getTime() - stat.birthtime
                            .getTime()) < 5000) {
                            this.fs.unlinkSync(this.configs['dependencies']
                                ['modules_folder'] + '/' + newModuleName + 
                                path);
                            this.files.fsExtra.copySync(file, this.configs
                                ['dependencies']['modules_folder'] + '/' + 
                                newModuleName + path, {
                                });
                            this.fs.utimesSync(this.configs
                                ['dependencies']['modules_folder'] + '/' + 
                                newModuleName + path, stat.birthtime,
                                stat.birthtime);
                        }
                    }
                }
            }
            this.rimraf.sync('./node_modules/' + module);
            return new Promise((resolve, reject) => {
                resolve();
            });
        } else {
            return this.files.moveFiles('./node_modules/' + module, 
                this.configs['dependencies']['modules_folder'] + '/' + 
                    newModuleName, {
                });
        }
    }
    
    /**
     * Given a module, move its node_modules folder contents into the 
     * node_modules folder such that require('*') conflicts don't occur.
     * @return {Promise} A promise that resolves when node_modules inside a 
     * modules package have been moved back to node_modules.
     */
    moveNodeModules(module, newModuleName) {
        let files, foundModule;
        // if source node_modules has one of the modules folders, abort!
        if (this.fs.existsSync(this.configs['dependencies']
            ['modules_folder'] + '/' + newModuleName + '/node_modules')) {
            files = this.fs.readdirSync(this.configs['dependencies']
            ['modules_folder'] + '/' + newModuleName + '/node_modules');
            foundModule = files.find((function(file) {
                let module, newModuleName;
                for (module of this.configs['dependencies']['modules']) {
                    if (typeof module == 'object') {
                        newModuleName = module[Object.keys(module)[0]];
                        module = Object.keys(module)[0];
                    } else {
                        newModuleName = module;
                    }

                    if (file == module) {
                        this.rimraf.sync(this.configs['dependencies']
                            ['modules_folder'] + '/' + newModuleName + 
                            '/node_modules/' + file);
                        return true;
                    }
                }
                return false;
            }).bind(this));
            if (foundModule) {
                console.log('SpiritDependencies Error: one of your modules ' + 
                    'uses a different version of an existing module! ' +
                    'Please resolve this version conflict ASAP.  Using local' + 
                    ' version but this may cause malfunction!');
            }
        } else {
            return new Promise((resolve, reject) => {
                resolve(); // okay, we did nothing.
            });
        }
        return this.files.moveFiles(this.configs['dependencies']
            ['modules_folder'] + '/' + newModuleName + '/node_modules', 
            './node_modules');
    }

    /**
     * @return {Boolean} True if the package exists.
     */
    packageExists(packageName) { 
        return this.fs.existsSync(this.modulesFolder() + packageName);
    }

    /**
     * Gets the package path.  If package is not in node_modules, searches
     * in the configured modules folder.
     */
    packagePath(packageName) {
        let file;
        file = this.modulesFolder() + packageName;
        if (this.fs.existsSync(file)) {
            return file;
        }
        file = this.files.getApplicationDirectory() + '/' + 
                this.configs['dependencies']['modules_folder'] + '/' + 
                this.getModuleAlias(packageName);
        if (this.fs.existsSync(file)) {
            return file;
        }

        return false;
    }

    /**
     * Gets the package version of the supplied package.  If the package is not
     * found in the node_modules folder, check the configured modules folder.
     * @param {String} packageName The name of the package to find.
     * @return {String} The version number of the package or false if no package
     * was found.
     */
    packageVersion(packageName) { 
        if (!this.packageExists(packageName)) {
            let file = this.files.getApplicationDirectory() + '/' + 
                    this.configs['dependencies']['modules_folder'] + '/' + 
                    this.getModuleAlias(packageName);
            if (this.fs.existsSync(file)) {
                return JSON.parse(this.fs.readFileSync(file + 
                    '/package.json', 'UTF8'))['version'];
            }
            return false;
        } else  {
            return JSON.parse(this.fs.readFileSync(
                this.modulesFolder() + packageName + '/package.json', 'UTF8'))
                ['version'];
        }
    }

    /**
     * For a given script name, run the script (if it exists) across all 
     * modules.
     * @param {String} script The script name to run.
     */
    runModuleScripts(script) {
        let packageFolders = this.allModuleFolders();
        let packages = this.allPackageJSON();
        for (let packageName in packages) {
            let cwd = process.cwd();
            try {
                process.chdir(packageFolders[packageName]);
                require('child_process').execSync(packages[packageName]['scripts']
                    [script]);
            } catch(e) {
                console.warn('SpiritDependencies Warning: ' + 'An error ' + 
                    'occurred running the ' + script + ' script for ' + 
                    packageName, e);
            }
            process.chdir(cwd);
        }
    }

    /**
     * Setting up routes.
     */
    setupRoutes(app) {
        app.all('/spiritdependencies/check', function(req, res, next) {
            this.npmCheck().then((status) => {
                let $, idx, rin, rout, pkg, packages;
                packages = status.get('packages');
                rin = 0;
                rout = 0;
                for (idx in packages) {
                    pkg = packages[idx];
                    rin++;
                    (function(pkg) {
                        this.latestVersion(pkg.moduleName).then((pkg) => {
                            rout++;
                            if (rin == rout) {
                                res.send(packages);
                            }
                        });
                    }).bind(this)(pkg);
                }
            });
        }.bind(this));
    }

    /**
     * TODO: refactor using the static version of this function.
     * Symlinks a specified module in the node_modules folder to the 
     * configured modules folder and associated module folder.
     * @param {String} module The destination module name to symlink.
     * @param {String} newModuleName The module source which to symlink.
     * @param {String} modulesFolder (Optional) The source folder to symlink
     * from.  If no folder provided, reads the default configs folder.
     */
    symlinkModule(module, newModuleName, modulesFolder = '') {
        if (!modulesFolder || moulesFolder.length == 0) {
            modulesFolder = process.cwd() + '/' + 
            this.configs['dependencies']['modules_folder'] + '/';
        }
        this.fs.symlinkSync(modulesFolder + newModuleName, 
            this.modulesFolder() + module, 'dir');
    }

    /**
     * Symlinks a specified module in the node_modules folder to the 
     * configured modules folder and associated module folder.
     * @param {String} module The destination module name to symlink.
     * @param {String} newModuleName The module source which to symlink.
     * @param {String} modulesFolder (Optional) The source folder to symlink
     * from.  If no folder provided, reads the default configs folder.
     */
    static symlinkModule(module, newModuleName, modulesFolder = '', 
        nodeModulesFolder = '') {
        if (!nodeModulesFolder.length) {
            nodeModulesFolder = SpiritDependencies.modulesFolder();
        }
        require('fs').symlinkSync(modulesFolder + newModuleName, 
            nodeModulesFolder + module, 'dir');
    }

    /**
     * TODO: refactor using the static version of this function.
     * Symlinks all modules from the specified 
     * configured modules folder and associated module folder.
     */
    symlinkModules(modulesFolder = '') {
        let newModuleName;
        for (let module of this.configs['dependencies']['modules']) {
            if (typeof module == 'object') {
                newModuleName = module[Object.keys(module)[0]];
                module = Object.keys(module)[0];
            } else {
                newModuleName = module;
            }
            this.symlinkModule(module, newModuleName, modulesFolder);
        }
    }

    /**
     * Symlinks all modules from the specified 
     * configured modules folder and associated module folder.
     */
    static symlinkModules(modulesFolder = '', modules = [], 
        nodeModulesFolder = '') {
        let newModuleName;
        for (let module of modules) {
            if (typeof module == 'object') {
                newModuleName = module[Object.keys(module)[0]];
                module = Object.keys(module)[0];
            } else {
                newModuleName = module;
            }
            try {
                SpiritDependencies.symlinkModule(module, newModuleName, 
                    modulesFolder, nodeModulesFolder);
            } catch(e) {
                
            }
        }
    }


    /**
     * Unlinks module in node_modules *only if* it is a symlink.
     * @param {String} module A module name to unlink.
     */
    unlinkModule(module) {
        try {
            if (this.fs.lstatSync('./node_modules/' + module)
                        .isSymbolicLink()) {
                this.rimraf.sync('./node_modules/' + module);
            }
        } catch(e) {}
    }

    /**
     * For each module listed in the modules configuration, unlink the symlink
     * in the associated node_modules folder.  Useful for running npm update.
     */
    unlinkModules(modules = []) {
        let newModuleName;
        if (modules.length == 0) {
            modules = this.configs['dependencies']['modules'];
        }
        for (let module of modules) {
            if (typeof module == 'object') {
                newModuleName = module[Object.keys(module)[0]];
                module = Object.keys(module)[0];
            } else {
                newModuleName = module;
            }
            this.unlinkModule(module);
        }
    }
}

module.exports = SpiritDependencies;