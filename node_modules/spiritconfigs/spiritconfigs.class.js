"use strict";

/**
 * Wraps the SpiritFiles object to provide more articulated control over
 * JSON-based configuration files.  Allows defaults and overrides to be used.
 * @class
 */
class SpiritConfigs {
    constructor() {
        if (!SpiritConfigs.instance) {
            SpiritConfigs.instance = this;
        } else {
            return SpiritConfigs.instance;
        }
        /** @type {Object} defaults */
        this.defaults = {};
        /** @type {Object} lastRead array of configs */
        this.lastRead   = {};
        /** @type {Object} overrides stored for overriding programmatically */
        this.overrides = {};

        this.chalk  = require('chalk');
        this.fs     = require('fs');
        this.files  = require('spiritfiles');
        this.path   = require('path');
        this.readline  = require('readline');

        this.loadDefaultsAndOverrides();
        this.readConfigs();
        this.hookShutdown();
    }

    /**
     * Returns all configs.
     * @return {Object} The last read configs.
     */
    all() {
        return this.lastRead;
    }

    /**
     * Attempts to reset the configs object.
     */
    cleanup() {
        if (this.fs.existsSync(__dirname + '/cache/overrides.json')) {
            this.fs.unlinkSync(__dirname + '/cache/overrides.json');
        }
        if (this.fs.existsSync(__dirname + '/cache/defaults.json')) {
            this.fs.unlinkSync(__dirname + '/cache/defaults.json');
        }
        this.lastRead = {};
        this.defaults = {};
        this.overrides = {};
    }

    /**
     * Creates a temporary config that is deleted at the end of the process
     * lifetime.
     * @param {String} name The name of the config file.
     * @param {Object} contents The JSON object to write to the file.
     * @return {Boolean} 
     */
    createConfig(name, contents) {
        this.files.createLocalFile('configs', name, JSON.stringify(contents), 
            true);
    }

    /**
     * Gets the last read configs.
     * @param {string} file The file key to read for.
     * @return {Object} Config matching file.
     */
    get(file) {
        if (this.lastRead.hasOwnProperty(file)) {
            return this.lastRead[file];
        }
        return false;
    }

    /**
     * Adds process hooks to listen when Node or the active process shuts down.
     */
    hookShutdown() {
        if (process.platform === "win32") {
            this.readline.createInterface ({
                input: process.stdin,
                output: process.stdout
            }).on ("SIGINT", () => {
                process.emit("SIGINT");
            });
        }
        // listen for TERM signal .e.g. kill
        process.on('SIGTERM', (function() {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        }).bind(this));
        // listen for INT signal e.g. Ctrl-C
        process.on('SIGINT', (function() {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        }).bind(this));
        process.on('exit', (function() {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        }).bind(this));
        process.on('SpiritConfigs Cleanup',  (function() {
            this.onShutdown();
        }).bind(this));
    }

    /**
     * Include relevant packages.
     */
    loadDefaultsAndOverrides() {
        if (!this.fs.existsSync(__dirname + '/cache')) {
            this.fs.mkdirSync('cache');
        }
        try {
            this.defaults = JSON.parse(this.fs.readFileSync(__dirname +
                '/cache/defaults.json', 'UTF8'));
        } catch(e) {
        }
        try {
            this.overrides = JSON.parse(this.fs.readFileSync(__dirname +
                '/cache/overrides.json', 'UTF8'));
        } catch(e) {
        }
    }


    /**
     * Removes cache files on shutdown.  If no files present in cache folder,
     * removes cache folders also.
     */
    onShutdown() {
        this.cleanup();
        try {
            this.fs.unlinkSync('cache');
        } catch(e) {

        }
    }

    /**
     * Using a files object, reads those files as configs filtering for .json
     * files and then applying defaults/overrides appropriately.
     * @param  {Array} files An array of files.
     * @return {Object<String, Object>} A configs object keyed by file, then a JSON object of
     * configs identified by that file.
     */
    parseFiles(files) {
        let config, configs, file, filename;
        configs = {};
        for (file of files) {
            if (typeof file != 'string') {
                continue;
            }
            file        = file.replace(/\\/g, '/');
            filename    = file.split('/');
            filename    = filename[filename.length - 1];
            if (filename.split('.').pop() != 'json') {
                continue;
            }
            filename    = filename.split('.').slice(0, -1).join('.');
            try {
                config = JSON.parse(this.fs.readFileSync(file, 'UTF8'));
            } catch(e) {
                console.error(this.chalk.red('SpiritConfigs Error: ') +
                    'had trouble reading the config ' +
                    this.chalk.yellow(filename) +
                    '.  Please check that the file contains valid JSON ' +
                    'syntax and try again: ' + file);
            }
            if (!this.defaults.hasOwnProperty(filename)) {
                this.defaults[filename] = {};
            }
            if (!this.overrides.hasOwnProperty(filename)) {
                this.overrides[filename] = {};
            }
            if (!configs[filename]) {
                configs[filename] = {};
            }
            configs[filename]    = Object.assign(this.defaults[filename],
                configs[filename], config, this.overrides[filename]);
        }

        this.lastRead = configs;
        return this.lastRead;
    }

    /**
     * Reads the configs using the SpiritFiles API.
     * @param  {String} fromFolder A folder to read from using the Files API.
     * @param  {function} updateFn Function to call when new configs are added.
     * @param  {number} updateInterval Time between checks on configs folder.
     * @return  {Object<String, Object>} Configs read into an object,
     * using the filenames as a key.
     */
    readConfigs(fromFolder, updateFn, updateInterval) {
        let files;
        if (typeof fromFolder == 'undefined')
            fromFolder  = 'configs';
        if (typeof updateFn != 'undefined') {
            files   = this.files.readFiles(fromFolder, (newFiles) => {
                updateFn(this.parseFiles(newFiles));
            }, updateInterval);
        } else {
            files   = this.files.readFiles(fromFolder);
        }
        return this.parseFiles(files);
    }

    /**
     * Sets a default for a particular settings config.  This is super handy if
     * you are authoring a library without expecting a config to exist/want to
     * ensure a block of code has no failure by way of a config access.
     * @param {String} file Filename to set the defaults for.
     * @param {Object} settings Settings object to load in.
     */
    setDefault(file, settings) {
        this.defaults[file] = settings;
        if (!this.lastRead[file]) {
            this.lastRead[file] = {};
        }
        this.lastRead[file] = Object.assign(settings, this.lastRead[file]);

        this.fs.writeFileSync(__dirname + '/cache/defaults.json',
            JSON.stringify(this.defaults));
    }

    /**
     * Sets a programmatic override for configs such that a reread will always
     *     be overridden.
     * @param {String} file     File/key for override.
     * @param {Object} settings Object to override with.
     */
    setOverride(file, settings) {
        this.overrides[file] = settings;
        if (!this.lastRead[file]) {
            this.lastRead[file] = {};
        }
        if (!this.defaults[file]) {
            this.defaults[file] = {};
        }
        this.lastRead[file] = Object.assign(this.defaults[file],
            this.lastRead[file], settings);

        this.fs.writeFileSync(__dirname + '/cache/overrides.json',
            JSON.stringify(this.overrides));
    }
}

module.exports = new SpiritConfigs();