'use strict';

/**
 * @class
 * Spiritfiles allows folders to be recursively read,
 * and it uses a cache to prevent unnecessary reads
 * when no modifications have been made.
 */
class SpiritFiles {
    constructor() {
        this.chalk  = require('chalk');
        this.fs     = require('fs');
        this.fsExtra = require('fs-extra');
        this.lastRead = {};
        this.path   = require('path');
        this.updateIntervalIds = {};
        this.updateIntervals = {};
        this.updateFns = {};
        this.readline = require('readline');
        this.rimraf = require('rimraf');
        this.rscandir = require('spiritrscandir');
        this.rscandirHelpers = require('spiritrscandir/' +
            'spiritrscandir.class.js');
        this.rscandirHelpers.SpiritRScandir.instance.setSort(
            this.rscandirHelpers.SpiritRScandirSortStrategy.DEPTH_FIRST);
        this.temporaryFiles = [];

        this.hookShutdown();
    }

    /**
     * Creates a file using filepath irrespective if the directory exists or
     * not.
     * @param {string} filepath The filepath to write.
     * @param {string} contents The contents to write to the file with.
     */
    addFile(filepath, contents) {
        this.writeFile(filepath, contents, false);
    }

    /**
     * Receives a JSON object of filepaths and corresponding contents.  Writes
     * the filepaths provided by the object's keys irrespective of if the
     * directories exist or not.
     * @param {Object} fileObject An object of keys as pathnames, and values as
     *     file contents.
     */
    addFiles(fileObject) {
        let contents, file;
        for (file in fileObject) {
            contents = fileObject[file];
            this.addFile(file, contents);
        }
    }
    

    /**
     * Calls the functions listening for updates from a particular folder.
     * @param  {string} fromFolder They folder key to use when accessing the
     *     updateFn's array.
     */
    callUpdateFns(fromFolder) {
        let files, updateFn;
        files = this.lastRead[fromFolder];
        for (updateFn of this.updateFns[fromFolder]) {
            updateFn(files);
        }
    }

    /**
     * Runs a basic indexOf diff between the lastRead array of files and a
     * fresh file read.  If there is a diff, return true.  Relies on
     * this.readAllFiles/SpiritRScandir to determine a reliable caching 
     * strategy so as not to overwhelm the system.
     * @param  {string} fromFolder The folder to read new results for check for
     *     updates for.
     * @return {boolean} True if there are new updates in the fromFolder.
     */
    checkFolderUpdates(fromFolder, files) {
        let lastReadFile;
        if (!files) {
            clearInterval(this.updateIntervalIds[fromFolder]);
            return false;
        }
        if (this.lastRead[fromFolder].length != files.length) {
            this.lastRead[fromFolder] = files;
            return true;
        }
        for (lastReadFile of this.lastRead[fromFolder]) {
            if (files.indexOf(lastReadFile) == -1) {
                this.lastRead[fromFolder] = files;
                return true;
            }
        }
        return false;
    }

    /**
     * Clears the update interval for fromFolder.
     * @param  {string} fromFolder The fromFolder to no longer check for updates
     *     on.
     */
    clearUpdateIntervals(fromFolder) {
        if (this.updateIntervalIds[fromFolder]) {
            clearInterval(this.updateIntervalIds[fromFolder]);
            delete this.updateIntervalIds[fromFolder];
        }
    }

    /**
     * Creates a file.
     * @param  {string} fromFolder Folder name to use for files.
     * @param  {string} filename   Path to store file under fromFolder.
     * @param  {string} contents   Contents of the file.
     * @param  {string} packageName Package name to put file in.
     * @param  {boolean} temporary  If temporary, will be deleted on shutdown.
     */
    createFile(fromFolder, filename, contents, packageName, temporary) {
        let cwd, path;
        cwd = process.cwd();
        path = '';
        if (packageName) {
            path += 'node_modules/' + packageName + '/';
            if (!this.fs.existsSync(path)) {
                console.log(this.chalk.red('SpiritFiles error: ') +
                    'tried to create file under package that DNE', packageName,
                    path);
                return;
            }
        }
        if (this.fs.existsSync(path  + fromFolder + '/' + filename)) {
            console.log(this.chalk.yellow('SpiritFiles warning: ') + 'tried to ' +
                'create file that already exists!', path  + fromFolder + '/' + 
                filename);
            return;
        }
        this.writeFile(path  + fromFolder + '/' + filename, contents);
        if (temporary) {
            if ((path + fromFolder).length > 0) {
                filename = path + fromFolder + '/' + filename;
            }
            // store this so we delete it at exit
            this.temporaryFiles.push(filename);
        }
    }

    /**
     * Creates a file
     * @param  {string} fromFolder Folder name to use for files.
     * @param  {string} filename   Path to store file under fromFolder.
     * @param  {string} contents   Contents of the file.
     * @param  {boolean} temporary  If temporary, will be deleted on shutdown.
     */
    createLocalFile(fromFolder, filename, contents, temporary) {
        this.createFile(fromFolder, filename, contents, null, temporary);
    }

    /**
     * Creates a file
     * @param  {string} fromFolder Folder name to use for files.
     * @param  {string} filename   Path to store file under fromFolder.
     * @param  {string} contents   Contents of the file.
     * @param  {string} packageName Package name to put file in.
     * @param  {boolean} temporary  If temporary, will be deleted on shutdown.
     */
    createPackageFile(fromFolder, filename, contents, packageName, temporary) {
        this.createFile(fromFolder, filename, contents, packageName, temporary);
    }

    /**
     * Creates the update timer such that the updateFn is added to the timer
     * for the fromFolder map of callbacks.  If the updateInterval is less
     * than the current updateInterval, then the smaller of the two
     * updateInterval's is used.
     * @param  {string} fromFolder The folder to read files from.
     * @param  {function(Array)} updateFn Function will call with new results
     *     when they occur.  Function will be added to existing or new map
     *     keyed by the fromFolder.
     * @param  {number} updateInterval The interval time to use for checking
     *     for updates.  If fromFolder is already being monitored for updates
     *     on an interval, then updateInterval will be the new interval if
     *     updateInterval is smaller than the current interval.
     * @param {boolean} allFiles If true, also check for updates in package
     *     files.
     */
    createUpdateTimer(fromFolder, updateFn, updateInterval, allFiles) {
        if (!this.updateFns[fromFolder]) {
            this.updateFns[fromFolder] = [];
        }
        this.updateFns[fromFolder].push(updateFn);
        if (!this.updateIntervals[fromFolder]) {
            this.updateIntervals[fromFolder] = updateInterval || 5000;
        }
        if (updateInterval &&
            updateInterval < this.updateIntervals[fromFolder]) {
            this.updateIntervals[fromFolder] = updateInterval;
            this.clearUpdateIntervals(fromFolder);
        }
        if (!this.updateIntervalIds[fromFolder]) {
            this.updateIntervalIds[fromFolder] = setInterval(() => {
                if (allFiles && this.checkFolderUpdates(fromFolder,
                    this.readAllFiles(fromFolder))) {
                    this.callUpdateFns(fromFolder);
                }
                else if (this.checkFolderUpdates(fromFolder,
                    this.readLocalFiles(fromFolder))) {
                    this.callUpdateFns(fromFolder);
                }
            }, this.updateIntervals[fromFolder]);
        }
    }

    /**
     * Gets the most relevant application directory.  This is defined by taking
     * the currently executing file folder, and checking or moving up until the
     * directory is no longer inside a node_modules folder.
     * @return {string} The most relevant application directory.
     */
    getApplicationDirectory() {
        let path;
        path = this.path.dirname(require.main.filename).replace(/\\/g, '/');
        while (path.indexOf('node_modules') != -1) {
            path = path.split('/').slice(0, -1).join('/');
        }
        return path;
    }

    /**
     * Gets the currently executing Node Script's directory.
     * @return {string} The current process target directory.
     */
    getProcessDirectory() {
        return this.path.dirname(require.main.filename);
    }

    /**
     * Adds process hooks to listen when Node or the active process shuts down.
     */
    hookShutdown() {
        if (process.platform === 'win32') {
            this.readline.createInterface ({
                input: process.stdin,
                output: process.stdout
            }).on ('SIGINT', () => {
                process.emit('SIGINT');
            });
        }
        // listen for TERM signal .e.g. kill
        process.on('SIGTERM', (function() {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        }).bind(this));
        // listen for INT signal e.g. Ctrl-C
        process.on('SIGINT', (function() {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        }).bind(this));
        process.on('exit', (function() {
            this.onShutdown();
            setTimeout(() => {
                process.exit();
            }, 1000);
        }).bind(this));
        process.on('SpiritFiles Cleanup',  (function() {
            this.onShutdown();
        }).bind(this));
    }

    /**
     * Moves either a file or a directory to a destination.
     * @param {string} source The source filename or directory.
     * @param {string} destination The destination filename or directory.
     * @param {Object} options An options object that may include overwrite.
     * @return {Promise} A promise that resolves when the operation is complete,
     * rejects if the source file or directory does not exist.
     */
    moveFiles(source, destination, options) {
        if (!options) {
            options = {};
        }
        return new Promise((resolve, reject) => {
            if (!this.fs.existsSync(source)) {
                reject();
            }
            this.fsExtra.move(source, destination, options, function(err) {
                if (err) {
                    reject(err);
                } else {
                    resolve();
                }
            });
        });
    }

    /**
     * Removes temporarily  created files on shutdown.  Any folders created
     * explicitly for temporarily files are also removed.
     */
    onShutdown() {
        let file;
        console.info(this.chalk.cyan('SpiritFiles info: ') + 'cleaning up ' + 
            'temporarily created files.');
        for (file of this.temporaryFiles) {
            if (this.fs.existsSync(file)) {
                this.fs.unlinkSync(file);
            }
            while (this.rscandir(this.path.dirname(file))
                .length == 0 ) {
                    console.warn(this.chalk.yellow('SpiritFiles warning: ') + 
                        'deleting folder with no files left', 
                        this.path.dirname(file));
                this.rimraf.sync(this.path.dirname(file));
                file = this.path.dirname(file);
            }
        }
    }

    /**
     * @param  {String} fromFolder The folder from which to read.
     * @param  {function(Array)} updateFn Function will call with new results
     *     when they occur.
     * @param  {number} updateInterval The interval time to use for checking
     *     for updates.
     * @return {Array} A listing of files.
     */
    readFiles(fromFolder, updateFn, updateInterval) {
        let files;
        files = this.readAllFiles(fromFolder);
        if (updateFn) {
            this.lastRead[fromFolder] = files;
            this.createUpdateTimer(fromFolder, updateFn, updateInterval);
        }
        return files;
    }

    /**
     * Reads files from the fromFolder.
     * @param  {String} fromFolder The folder from which to read.
     * @param  {function(Array)} updateFn Function will call with new results
     *     when they occur.
     * @param  {number} updateInterval The interval time to use for checking
     *     for updates.
     * @return {Array} A listing of files.
     */
    readLocalFiles(fromFolder, updateFn, updateInterval) {
        let curPath, files, timer;
        updateInterval = updateInterval || 5000; // every 5s
        files = [];
        curPath = process.cwd() + '/' + fromFolder;
        if (this.fs.existsSync(curPath)) {
            files = files.concat(this.rscandir(curPath));
        } else {
            console.warn(this.chalk.yellow('SpiritFile warning: ') + 'the ' +
                'requested read folder does not exist!', curPath, fromFolder);
            return false;
        }

        if (updateFn) {
            this.lastRead[fromFolder] = files;
            this.createUpdateTimer(fromFolder, updateFn, updateInterval);
        }

        return files;
    }

    /**
     * Reads all files from node_modules filesystem and the local process
     *     folder.  If updateFn is supplied, node_modules files are checked in
     *     addition to the local changes.  This usually shouldn't be need for
     *     updates on the dependency files, but this interface exists anyway.
     * @param  {String} fromFolder The folder from which to read.
     * @param  {function(Array)} updateFn Function will call with new results
     *     when they occur.
     * @param  {number} updateInterval The interval time to use for checking
     *     for updates.
     * @return {Array} An array of files read from each package in node_modules.
     */
    readAllFiles(fromFolder, updateFn, updateInterval) {
        let curPath, cwd, files, i, packagePath, packages, path;
        updateInterval = updateInterval || 5000; // every 5s
        if (arguments[3] && typeof arguments[3] != 'function') {
            path = arguments[3];
        } else {
            path = '';
        }
        files = [];
        packages = [];
        cwd = process.cwd();
        curPath = process.cwd() + path + '/node_modules';
        if (this.fs.existsSync(curPath)) {
            packages = this.fs.readdirSync(curPath);
            for (let aPackage of packages) {
                if (aPackage.toString().length > 50) {
                    // sometimes long pathnames cause errors
                    console.warn(this.chalk.yellow('SpiritFile warning: ') +
                        'filename detected' + ' longer than 50 characters.');
                    continue;
                }
                try {
                    if (this.fs.lstatSync(curPath + '/' + aPackage)
                        .isSymbolicLink()) {
                            packagePath = this.fs.readlinkSync(curPath + '/' + 
                                aPackage).replace(/\\/g, '/');
                        } else {
                            packagePath = curPath + '/' + aPackage;
                        }
                } catch(e) {
                    packagePath = curPath + '/' + aPackage;
                }
                try {
                    if (this.fs.lstatSync(packagePath).isDirectory()) {
                        if (this.fs.existsSync(packagePath +
                            '/' + fromFolder)) {
                            files = (this.rscandir(packagePath + '/' + fromFolder))
                                .concat(files);
                        }
                        // TODO: update for symlinks
                        if (this.fs.existsSync(process.cwd() + path +
                            '/node_modules/' + aPackage + '/node_modules')) {
                            files = (this.readAllFiles(fromFolder,
                                updateFn, updateInterval,
                                path + '/node_modules/' + aPackage)).concat(files);
                        }
                    }
                } catch(e) {}
            }
        } else {
            console.warn(this.chalk.yellow('SpiritFile warning: ') + 'the ' +
                'requested read folder does not exist!', curPath, fromFolder);
            return false;
        }

        if (updateFn) {
            this.lastRead[fromFolder] = files;
            this.createUpdateTimer(fromFolder, updateFn, updateInterval);
        }

        if (!arguments[3]) {
            files = files.concat(this.readLocalFiles(fromFolder));
        }

        return files;
    }

    /**
     * Recursively removes the directory specified.
     * @param  {string} directory Directory to remove.
     */
    rrmdir(directory) {
        this.rimraf.sync(directory);
    }

    /**
     * Creates a file using filepath irrespective if the directory exists or
     * not.
     * @param {string} filepath The filepath to write.
     * @param {string} contents The contents to write to the file with.
     */
    writeFile(filepath, contents, overwrite) {
        let cwd, directories, filename;
        if (typeof overwrite == 'undefined') {
            overwrite = true;
        }
        cwd = process.cwd();
        filepath = filepath.replace(/\\/g, '/');
        directories = filepath.split('/');
        filename = directories.pop();
        for (let dir of directories) {
            if (dir.length == 0) {
                continue;
            }
            if (!this.fs.existsSync(dir)) {
                this.fs.mkdirSync(dir);
            }
            process.chdir(dir);
        }
        if (!overwrite && this.fs.existsSync(filename)) {
            // do nothing
        } else {
            this.fs.writeFileSync(filename, contents);
        }
        process.chdir(cwd);
    }
}

module.exports = SpiritFiles;